<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Access Control -->
    <script src="../../../components/AccessGuard.js"></script>
    <script>
        AccessGuard.require('sorted');
    </script>
    <!-- Achievement & Progress Integration -->
    <script src="../../../components/AchievementManager.js"></script>
    <script src="../../../components/ModuleProgress.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Key Derivation Functions - House of the Key</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --house-color: #f59e0b;
            --house-glow: rgba(245, 158, 11, 0.4);
            --bg-dark: #0a0a12;
            --bg-card: rgba(15, 15, 25, 0.8);
            --text-primary: #e8e8f0;
            --text-secondary: #8888aa;
            --cyan-accent: #06b6d4;
            --success-green: #10b981;
            --warning-red: #ef4444;
            --info-blue: #3b82f6;
        }

        body {
            min-height: 100vh;
            background: var(--bg-dark);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: var(--text-primary);
            overflow-x: hidden;
        }

        /* Header */
        .module-header {
            padding: 20px 30px;
            background: rgba(10, 10, 18, 0.95);
            border-bottom: 1px solid rgba(245, 158, 11, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .back-btn {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: 1px solid rgba(245, 158, 11, 0.3);
            background: transparent;
            color: var(--house-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            font-size: 1.2rem;
        }

        .back-btn:hover {
            background: rgba(245, 158, 11, 0.1);
            transform: translateX(-2px);
        }

        .module-title {
            font-size: 1rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        .house-badge {
            font-size: 0.7rem;
            padding: 4px 12px;
            background: rgba(245, 158, 11, 0.15);
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: 20px;
            color: var(--house-color);
            letter-spacing: 0.1em;
        }

        .progress-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .progress-bar {
            width: 100px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--house-color);
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Main Content */
        .module-content {
            max-width: 1000px;
            margin: 0 auto;
            padding: 40px 30px 100px;
        }

        .intro-section {
            text-align: center;
            margin-bottom: 60px;
            padding: 40px 30px;
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.05), rgba(6, 182, 212, 0.05));
            border-radius: 16px;
            border: 1px solid rgba(245, 158, 11, 0.2);
        }

        .intro-section h1 {
            font-size: 2.5rem;
            margin-bottom: 15px;
            background: linear-gradient(135deg, var(--house-color), var(--cyan-accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .intro-section .subtitle {
            font-size: 1.1rem;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        /* Content Sections */
        .content-section {
            margin-bottom: 50px;
            opacity: 0;
            transform: translateY(20px);
            animation: fadeInUp 0.6s ease forwards;
        }

        .content-section:nth-child(1) { animation-delay: 0.1s; }
        .content-section:nth-child(2) { animation-delay: 0.2s; }
        .content-section:nth-child(3) { animation-delay: 0.3s; }
        .content-section:nth-child(4) { animation-delay: 0.4s; }
        .content-section:nth-child(5) { animation-delay: 0.5s; }

        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .section-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(245, 158, 11, 0.3);
        }

        .section-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.2), rgba(6, 182, 212, 0.2));
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
        }

        .section-header h2 {
            font-size: 1.8rem;
            color: var(--house-color);
        }

        .section-content {
            padding-left: 0;
        }

        .section-content p {
            line-height: 1.8;
            color: var(--text-secondary);
            margin-bottom: 20px;
            font-size: 1rem;
        }

        /* Info Cards */
        .info-card {
            background: var(--bg-card);
            border: 1px solid rgba(245, 158, 11, 0.2);
            border-radius: 12px;
            padding: 25px;
            margin: 25px 0;
            transition: all 0.3s ease;
        }

        .info-card:hover {
            border-color: rgba(245, 158, 11, 0.4);
            box-shadow: 0 4px 20px rgba(245, 158, 11, 0.1);
            transform: translateY(-2px);
        }

        .info-card h3 {
            color: var(--cyan-accent);
            margin-bottom: 15px;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .info-card .card-icon {
            font-size: 1.2rem;
        }

        /* Code Blocks */
        .code-block {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(6, 182, 212, 0.3);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            color: var(--cyan-accent);
            overflow-x: auto;
            position: relative;
        }

        .code-block::before {
            content: 'CODE';
            position: absolute;
            top: 8px;
            right: 12px;
            font-size: 0.7rem;
            color: rgba(6, 182, 212, 0.5);
            letter-spacing: 0.1em;
        }

        .code-block pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* Lists */
        .custom-list {
            list-style: none;
            padding: 0;
        }

        .custom-list li {
            padding: 12px 0 12px 35px;
            position: relative;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .custom-list li::before {
            content: '‚ñπ';
            position: absolute;
            left: 10px;
            color: var(--house-color);
            font-size: 1.2rem;
        }

        /* Comparison Table */
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            background: var(--bg-card);
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(245, 158, 11, 0.2);
        }

        .comparison-table th {
            background: rgba(245, 158, 11, 0.15);
            color: var(--house-color);
            padding: 15px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid rgba(245, 158, 11, 0.3);
        }

        .comparison-table td {
            padding: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
        }

        .comparison-table tr:last-child td {
            border-bottom: none;
        }

        .comparison-table tr:hover {
            background: rgba(245, 158, 11, 0.05);
        }

        /* Warning/Info Boxes */
        .alert-box {
            padding: 20px;
            border-radius: 10px;
            margin: 25px 0;
            border-left: 4px solid;
            display: flex;
            gap: 15px;
            align-items: start;
        }

        .alert-box.warning {
            background: rgba(239, 68, 68, 0.1);
            border-color: var(--warning-red);
        }

        .alert-box.info {
            background: rgba(59, 130, 246, 0.1);
            border-color: var(--info-blue);
        }

        .alert-box.success {
            background: rgba(16, 185, 129, 0.1);
            border-color: var(--success-green);
        }

        .alert-box .alert-icon {
            font-size: 1.5rem;
            flex-shrink: 0;
        }

        .alert-box.warning .alert-icon { color: var(--warning-red); }
        .alert-box.info .alert-icon { color: var(--info-blue); }
        .alert-box.success .alert-icon { color: var(--success-green); }

        .alert-box .alert-content h4 {
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .alert-box .alert-content p {
            margin: 0;
            line-height: 1.6;
        }

        /* Visual Diagrams */
        .visual-diagram {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(6, 182, 212, 0.3);
            border-radius: 12px;
            padding: 30px;
            margin: 30px 0;
            text-align: center;
        }

        .diagram-title {
            color: var(--cyan-accent);
            margin-bottom: 20px;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .flow-diagram {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        .flow-box {
            padding: 15px 25px;
            background: rgba(245, 158, 11, 0.1);
            border: 2px solid rgba(245, 158, 11, 0.3);
            border-radius: 8px;
            color: var(--house-color);
            font-weight: 600;
            min-width: 120px;
        }

        .flow-arrow {
            color: var(--cyan-accent);
            font-size: 1.5rem;
        }

        /* Parameter Grid */
        .param-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }

        .param-card {
            background: rgba(6, 182, 212, 0.05);
            border: 1px solid rgba(6, 182, 212, 0.2);
            border-radius: 10px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .param-card:hover {
            border-color: rgba(6, 182, 212, 0.4);
            transform: translateY(-3px);
        }

        .param-card .param-name {
            color: var(--cyan-accent);
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 1.1rem;
        }

        .param-card .param-desc {
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.6;
        }

        /* Complete Button */
        .complete-section {
            margin-top: 60px;
            text-align: center;
            padding: 40px;
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(6, 182, 212, 0.1));
            border-radius: 16px;
            border: 1px solid rgba(245, 158, 11, 0.3);
        }

        .complete-btn {
            padding: 15px 40px;
            background: linear-gradient(135deg, var(--house-color), var(--cyan-accent));
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.3);
        }

        .complete-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(245, 158, 11, 0.4);
        }

        .complete-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(245, 158, 11, 0.3);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(245, 158, 11, 0.5);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .intro-section h1 {
                font-size: 2rem;
            }

            .section-header h2 {
                font-size: 1.5rem;
            }

            .flow-diagram {
                flex-direction: column;
            }

            .flow-arrow {
                transform: rotate(90deg);
            }

            .param-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="module-header">
        <div class="header-left">
            <button class="back-btn" onclick="window.location.href='../../../index.html'" title="Back to Key House">‚Üê</button>
            <h1 class="module-title">Key Derivation Functions</h1>
            <span class="house-badge">HOUSE OF THE KEY</span>
        </div>
        <div class="progress-indicator">
            <span id="scroll-progress">0%</span>
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="module-content">
        <!-- Introduction -->
        <section class="intro-section">
            <h1>Key Derivation Functions</h1>
            <p class="subtitle">
                Transforming human-memorable passwords into cryptographically secure keys through
                computational work, salt, and adaptive complexity. The foundation of modern password security.
            </p>
        </section>

        <!-- Section 1: Why KDFs Matter -->
        <section class="content-section">
            <div class="section-header">
                <div class="section-icon">üîê</div>
                <h2>Why Key Derivation Functions Matter</h2>
            </div>
            <div class="section-content">
                <p>
                    Passwords are not keys. A 128-bit AES key has 2<sup>128</sup> possible values, but a typical
                    8-character password has far fewer combinations. Even worse, humans choose predictable passwords.
                    Key Derivation Functions (KDFs) bridge this gap by transforming weak passwords into strong cryptographic keys.
                </p>

                <div class="info-card">
                    <h3><span class="card-icon">‚ö†Ô∏è</span>The Problem with Direct Hashing</h3>
                    <p>
                        If you store passwords as <code>SHA256(password)</code>, attackers can test billions of
                        passwords per second using GPUs. Modern hardware can compute over 100 billion SHA256 hashes
                        per second. At that rate, all 8-character passwords could be cracked in hours.
                    </p>
                </div>

                <div class="visual-diagram">
                    <div class="diagram-title">Direct Hash vs KDF</div>
                    <div class="flow-diagram">
                        <div class="flow-box">Password</div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-box">SHA256</div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-box">Hash (0.000001s)</div>
                    </div>
                    <p style="color: var(--warning-red); margin: 20px 0;">vs</p>
                    <div class="flow-diagram">
                        <div class="flow-box">Password</div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-box">KDF (100,000 iterations)</div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-box">Key (0.1s)</div>
                    </div>
                </div>

                <ul class="custom-list">
                    <li><strong>Speed is the enemy:</strong> Fast hashing helps attackers, not defenders</li>
                    <li><strong>Work factors:</strong> KDFs deliberately slow down computation</li>
                    <li><strong>Parallelization resistance:</strong> Memory-hard functions prevent GPU acceleration</li>
                    <li><strong>Future-proof:</strong> Adaptive parameters scale with hardware improvements</li>
                </ul>
            </div>
        </section>

        <!-- Section 2: Salt -->
        <section class="content-section">
            <div class="section-header">
                <div class="section-icon">üßÇ</div>
                <h2>Salt: The First Line of Defense</h2>
            </div>
            <div class="section-content">
                <p>
                    A salt is a unique random value added to each password before hashing. Without salt, identical
                    passwords produce identical hashes, enabling rainbow table attacks and revealing which users
                    have the same password.
                </p>

                <div class="info-card">
                    <h3><span class="card-icon">üé≤</span>Salt Generation and Storage</h3>
                    <div class="code-block">
                        <pre>
# Without salt - VULNERABLE
user1: password123 ‚Üí hash("password123") ‚Üí 8c6976e5b5...
user2: password123 ‚Üí hash("password123") ‚Üí 8c6976e5b5...  ‚Üê Same hash!

# With unique salt - SECURE
user1: password123 + a3f9e2b1 ‚Üí hash("password123a3f9e2b1") ‚Üí d4a8b3c2...
user2: password123 + 7c2d8f4a ‚Üí hash("password1237c2d8f4a") ‚Üí 9f1e6d3a...  ‚Üê Different!</pre>
                    </div>
                </div>

                <div class="alert-box success">
                    <div class="alert-icon">‚úì</div>
                    <div class="alert-content">
                        <h4>Salt Best Practices</h4>
                        <p>
                            <strong>Generate:</strong> Use cryptographically secure random number generators (CSRNG)<br>
                            <strong>Length:</strong> Minimum 16 bytes (128 bits), 32 bytes recommended<br>
                            <strong>Uniqueness:</strong> Every password gets a unique salt, even if passwords match<br>
                            <strong>Storage:</strong> Store salt in plaintext alongside the hash (it's not secret!)
                        </p>
                    </div>
                </div>

                <div class="code-block">
                    <pre>
# Secure salt generation examples
Python:  import os; salt = os.urandom(32)
Node.js: const salt = crypto.randomBytes(32)
OpenSSL: openssl rand -hex 32

# Database storage format
username | salt (hex)        | hash (hex)
---------|-------------------|------------------
alice    | a3f9e2b1c5d7...  | d4a8b3c29f1e...
bob      | 7c2d8f4a1e6b...  | 9f1e6d3a4b8c...</pre>
                </div>

                <div class="alert-box warning">
                    <div class="alert-icon">‚ö†Ô∏è</div>
                    <div class="alert-content">
                        <h4>Common Salt Mistakes</h4>
                        <p>
                            <strong>Never reuse salt:</strong> Same salt for all users defeats the purpose<br>
                            <strong>Don't use predictable values:</strong> Username, timestamp, or sequential IDs are not salt<br>
                            <strong>Don't keep salt secret:</strong> It's a public value; security comes from uniqueness
                        </p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 3: Work Factors -->
        <section class="content-section">
            <div class="section-header">
                <div class="section-icon">‚öôÔ∏è</div>
                <h2>Work Factors and Adaptive Security</h2>
            </div>
            <div class="section-content">
                <p>
                    The work factor controls how many iterations or computational steps the KDF performs. Higher
                    work factors mean slower hashing, which is acceptable for authentication (users wait 100ms)
                    but devastating for attackers (billions of guesses take years).
                </p>

                <div class="visual-diagram">
                    <div class="diagram-title">Work Factor Impact</div>
                    <div class="param-grid">
                        <div class="param-card">
                            <div class="param-name">10,000 iterations</div>
                            <div class="param-desc">Legacy systems (2010)<br>~50ms per hash<br>Vulnerable to modern attacks</div>
                        </div>
                        <div class="param-card">
                            <div class="param-name">100,000 iterations</div>
                            <div class="param-desc">Current minimum (2020)<br>~100ms per hash<br>Acceptable for most systems</div>
                        </div>
                        <div class="param-card">
                            <div class="param-name">600,000 iterations</div>
                            <div class="param-desc">NIST recommendation (2024)<br>~250ms per hash<br>Strong protection</div>
                        </div>
                    </div>
                </div>

                <div class="info-card">
                    <h3><span class="card-icon">üìä</span>Time-to-Crack Calculation</h3>
                    <div class="code-block">
                        <pre>
# Attack scenario: 8-character lowercase password
Password space: 26^8 = 208,827,064,576 combinations

With SHA256 (100B hashes/sec on GPU cluster):
Time to crack: 208B / 100B ‚âà 2 seconds

With PBKDF2 (100k iterations, 1M hashes/sec):
Time to crack: 208B / 1M ‚âà 58 hours

With Argon2 (proper tuning, 100 hashes/sec):
Time to crack: 208B / 100 ‚âà 66 years</pre>
                    </div>
                </div>

                <div class="alert-box info">
                    <div class="alert-icon">üí°</div>
                    <div class="alert-content">
                        <h4>Adaptive Security Principle</h4>
                        <p>
                            As hardware improves, attackers get faster. KDFs with tunable work factors let you
                            increase iterations over time without changing algorithms. Plan to increase your
                            work factor every 2-3 years to maintain equivalent security.
                        </p>
                    </div>
                </div>

                <ul class="custom-list">
                    <li><strong>Legitimate users:</strong> Hash password once per login (100-500ms acceptable)</li>
                    <li><strong>Attackers:</strong> Must hash billions of guesses (years of computation)</li>
                    <li><strong>Balance:</strong> Maximize work factor while keeping login time under 500ms</li>
                    <li><strong>Monitoring:</strong> Benchmark on your production hardware, not developer laptops</li>
                </ul>
            </div>
        </section>

        <!-- Section 4: PBKDF2 -->
        <section class="content-section">
            <div class="section-header">
                <div class="section-icon">üîë</div>
                <h2>PBKDF2: Password-Based Key Derivation v2</h2>
            </div>
            <div class="section-content">
                <p>
                    PBKDF2 (RFC 2898) is the oldest widely-used KDF, applying a pseudorandom function (like HMAC-SHA256)
                    repeatedly. It's simple, well-understood, and supported everywhere, but vulnerable to GPU/ASIC attacks
                    because it's not memory-hard.
                </p>

                <div class="visual-diagram">
                    <div class="diagram-title">PBKDF2 Algorithm</div>
                    <div class="flow-diagram">
                        <div class="flow-box">Password + Salt</div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-box">HMAC-SHA256</div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-box">XOR Results</div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-box">Repeat N times</div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-box">Derived Key</div>
                    </div>
                </div>

                <div class="code-block">
                    <pre>
# PBKDF2 Parameters
PRF:        HMAC-SHA256 (or HMAC-SHA512 for higher security)
Iterations: 600,000+ (NIST SP 800-132 recommendation for 2024)
Salt:       128+ bits
Output:     256 bits (32 bytes) for AES-256 keys

# Python example
from hashlib import pbkdf2_hmac
key = pbkdf2_hmac(
    'sha256',              # PRF
    password.encode(),     # Password as bytes
    salt,                  # Random salt
    600000,                # Iterations (NIST 2024)
    dklen=32               # 256-bit output
)</pre>
                </div>

                <div class="info-card">
                    <h3><span class="card-icon">üìã</span>NIST Recommendations (SP 800-132)</h3>
                    <ul class="custom-list">
                        <li>Minimum 210,000 iterations (as of 2023)</li>
                        <li>Recommended 600,000+ iterations for PBKDF2-HMAC-SHA256</li>
                        <li>Salt must be at least 128 bits</li>
                        <li>Use HMAC-SHA256 or HMAC-SHA512 as PRF</li>
                        <li>Increase iterations annually to maintain security</li>
                    </ul>
                </div>

                <div class="alert-box warning">
                    <div class="alert-icon">‚ö†Ô∏è</div>
                    <div class="alert-content">
                        <h4>PBKDF2 Limitations</h4>
                        <p>
                            <strong>Not memory-hard:</strong> GPUs and ASICs can parallelize effectively<br>
                            <strong>Requires high iterations:</strong> Need 600k+ iterations for adequate security<br>
                            <strong>Legacy systems:</strong> Often deployed with dangerously low iteration counts (10k)<br>
                            <strong>Better alternatives exist:</strong> Consider Argon2 for new systems
                        </p>
                    </div>
                </div>

                <div class="code-block">
                    <pre>
# Real-world usage: Django password hashing
pbkdf2_sha256$600000$aBcDeFgH$hash_output_here

# Components:
- Algorithm: pbkdf2_sha256
- Iterations: 600000
- Salt: aBcDeFgH (base64 encoded)
- Hash: hash_output_here (base64 encoded)</pre>
                </div>
            </div>
        </section>

        <!-- Section 5: bcrypt -->
        <section class="content-section">
            <div class="section-header">
                <div class="section-icon">üê°</div>
                <h2>bcrypt: Blowfish-Based Hashing</h2>
            </div>
            <div class="section-content">
                <p>
                    bcrypt (1999) is based on the Blowfish cipher with an expensive key schedule. Its cost factor
                    doubles work for each increment, making it naturally adaptive. bcrypt is memory-efficient but
                    has a 72-byte password limit.
                </p>

                <div class="visual-diagram">
                    <div class="diagram-title">bcrypt Cost Factor</div>
                    <div class="param-grid">
                        <div class="param-card">
                            <div class="param-name">Cost 10</div>
                            <div class="param-desc">2<sup>10</sup> = 1,024 iterations<br>~100ms<br>Minimum acceptable</div>
                        </div>
                        <div class="param-card">
                            <div class="param-name">Cost 12</div>
                            <div class="param-desc">2<sup>12</sup> = 4,096 iterations<br>~250ms<br>Current recommendation</div>
                        </div>
                        <div class="param-card">
                            <div class="param-name">Cost 14</div>
                            <div class="param-desc">2<sup>14</sup> = 16,384 iterations<br>~1000ms<br>High security</div>
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <pre>
# bcrypt hash format
$2b$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW
 ‚îÇ  ‚îÇ  ‚îÇ                                  ‚îÇ
 ‚îÇ  ‚îÇ  ‚îî‚îÄ Salt (22 chars, base64)        ‚îî‚îÄ Hash (31 chars, base64)
 ‚îÇ  ‚îî‚îÄ Cost factor (12 = 2^12 rounds)
 ‚îî‚îÄ Algorithm identifier ($2b$ = bcrypt)

# Node.js example
const bcrypt = require('bcrypt');
const saltRounds = 12;  // Cost factor
const hash = await bcrypt.hash(password, saltRounds);

# Verification
const match = await bcrypt.compare(password, hash);</pre>
                </div>

                <div class="info-card">
                    <h3><span class="card-icon">‚ö°</span>bcrypt Strengths</h3>
                    <ul class="custom-list">
                        <li><strong>Adaptive:</strong> Easy to increase cost factor as hardware improves</li>
                        <li><strong>Resistant to parallelization:</strong> Expensive key setup phase</li>
                        <li><strong>Battle-tested:</strong> 25+ years of cryptanalysis, no major breaks</li>
                        <li><strong>Wide support:</strong> Libraries available for every major language</li>
                        <li><strong>Auto-salting:</strong> Most implementations handle salt generation automatically</li>
                    </ul>
                </div>

                <div class="alert-box warning">
                    <div class="alert-icon">‚ö†Ô∏è</div>
                    <div class="alert-content">
                        <h4>The 72-Byte Password Limit</h4>
                        <p>
                            bcrypt truncates passwords at 72 bytes. For most users this isn't a problem, but long
                            passphrases or Unicode characters can exceed this. Workaround: pre-hash with SHA256,
                            then bcrypt the hash (but this introduces complexity).
                        </p>
                    </div>
                </div>

                <div class="code-block">
                    <pre>
# Handling long passwords (workaround)
import hashlib
pre_hash = hashlib.sha256(long_password.encode()).hexdigest()
bcrypt_hash = bcrypt.hash(pre_hash, cost_factor)

# Migration: Increasing cost factor
# Old: cost=10, New: cost=12
if (bcrypt.getRounds(stored_hash) < 12) {
    if (bcrypt.compare(password, stored_hash)) {
        new_hash = bcrypt.hash(password, 12);
        database.update(user, new_hash);
    }
}</pre>
                </div>
            </div>
        </section>

        <!-- Section 6: scrypt -->
        <section class="content-section">
            <div class="section-header">
                <div class="section-icon">üíæ</div>
                <h2>scrypt: Memory-Hard Key Derivation</h2>
            </div>
            <div class="section-content">
                <p>
                    scrypt (2009) was the first widely-adopted memory-hard KDF. By requiring large amounts of RAM,
                    it makes GPU and ASIC attacks economically infeasible. scrypt is used by Litecoin, Tarsnap,
                    and several password managers.
                </p>

                <div class="visual-diagram">
                    <div class="diagram-title">scrypt Parameters</div>
                    <div class="param-grid">
                        <div class="param-card">
                            <div class="param-name">N (CPU/Memory Cost)</div>
                            <div class="param-desc">Must be power of 2<br>N=2<sup>14</sup> = 16,384 (16 MB)<br>N=2<sup>20</sup> = 1,048,576 (1 GB)</div>
                        </div>
                        <div class="param-card">
                            <div class="param-name">r (Block Size)</div>
                            <div class="param-desc">Typically 8<br>Memory = 128 √ó N √ó r bytes<br>Affects parallelization</div>
                        </div>
                        <div class="param-card">
                            <div class="param-name">p (Parallelization)</div>
                            <div class="param-desc">Typically 1<br>Higher = more parallel threads<br>Increases total memory</div>
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <pre>
# scrypt parameter selection
# Conservative (2020): N=2^14, r=8, p=1 ‚Üí 16 MB, ~100ms
# Recommended (2024): N=2^16, r=8, p=1 ‚Üí 64 MB, ~300ms
# High security:      N=2^20, r=8, p=1 ‚Üí 1 GB,  ~5s

# Python example (requires py-scrypt or hashlib in Python 3.6+)
import hashlib
key = hashlib.scrypt(
    password.encode(),
    salt=salt,
    n=2**16,      # CPU/memory cost (65,536)
    r=8,          # Block size
    p=1,          # Parallelization
    dklen=32      # Output length
)

# Memory usage: 128 √ó 65,536 √ó 8 = 64 MB</pre>
                </div>

                <div class="info-card">
                    <h3><span class="card-icon">üõ°Ô∏è</span>Why Memory-Hardness Matters</h3>
                    <p>
                        GPUs excel at parallel computation but have limited memory per core. A GPU with 10,000 cores
                        and 16 GB RAM can only run 250 concurrent scrypt(N=2<sup>16</sup>) instances, versus billions
                        of PBKDF2 hashes. ASICs face similar economic constraints‚Äîmemory is expensive at scale.
                    </p>
                </div>

                <div class="alert-box info">
                    <div class="alert-icon">üí°</div>
                    <div class="alert-content">
                        <h4>Tuning scrypt Parameters</h4>
                        <p>
                            <strong>Start with N:</strong> Double it until you hit ~100-200ms on your hardware<br>
                            <strong>Keep r=8, p=1:</strong> Default values work well for most applications<br>
                            <strong>Monitor memory:</strong> Ensure total memory (p √ó 128 √ó N √ó r) fits in RAM<br>
                            <strong>Test under load:</strong> Concurrent logins multiply memory requirements
                        </p>
                    </div>
                </div>

                <div class="code-block">
                    <pre>
# Real-world usage: Tarsnap backup encryption
scrypt(
    password,
    salt,
    N=2^14,    # 16 MB memory
    r=8,
    p=1
)

# Interactive vs non-interactive (OpenSSL scrypt)
# Interactive (human waiting): N=2^14, r=8, p=1
# Non-interactive (file encryption): N=2^20, r=8, p=1</pre>
                </div>
            </div>
        </section>

        <!-- Section 7: Argon2 -->
        <section class="content-section">
            <div class="section-header">
                <div class="section-icon">üèÜ</div>
                <h2>Argon2: Winner of the Password Hashing Competition</h2>
            </div>
            <div class="section-content">
                <p>
                    Argon2 (2015) won the Password Hashing Competition and is the current state-of-the-art. It offers
                    three variants optimized for different attack scenarios, configurable memory usage, and resistance
                    to both GPU and side-channel attacks.
                </p>

                <div class="visual-diagram">
                    <div class="diagram-title">Argon2 Variants</div>
                    <div class="param-grid">
                        <div class="param-card">
                            <div class="param-name">Argon2d</div>
                            <div class="param-desc">Data-dependent<br>Fastest, most resistant to GPU<br>Vulnerable to side-channels</div>
                        </div>
                        <div class="param-card">
                            <div class="param-name">Argon2i</div>
                            <div class="param-desc">Data-independent<br>Resistant to side-channels<br>Slightly slower</div>
                        </div>
                        <div class="param-card">
                            <div class="param-name">Argon2id</div>
                            <div class="param-desc">Hybrid (recommended)<br>Best of both worlds<br>Default choice</div>
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <pre>
# Argon2 parameters
m (memory):      Memory in KB (recommended: 64 MB = 65,536 KB)
t (time):        Number of iterations (recommended: 3-4)
p (parallelism): Number of threads (recommended: 4)

# Hash format
$argon2id$v=19$m=65536,t=3,p=4$salt$hash
    ‚îÇ       ‚îÇ         ‚îÇ         ‚îÇ     ‚îÇ
    ‚îÇ       ‚îÇ         ‚îÇ         ‚îÇ     ‚îî‚îÄ Hash output
    ‚îÇ       ‚îÇ         ‚îÇ         ‚îî‚îÄ Salt (base64)
    ‚îÇ       ‚îÇ         ‚îî‚îÄ Parameters (memory, time, parallelism)
    ‚îÇ       ‚îî‚îÄ Version
    ‚îî‚îÄ Variant (id, i, or d)

# Node.js example (argon2 package)
const argon2 = require('argon2');
const hash = await argon2.hash(password, {
    type: argon2.argon2id,
    memoryCost: 65536,  // 64 MB
    timeCost: 3,        // Iterations
    parallelism: 4      // Threads
});</pre>
                </div>

                <div class="info-card">
                    <h3><span class="card-icon">‚öôÔ∏è</span>Argon2 Parameter Tuning</h3>
                    <ul class="custom-list">
                        <li><strong>Memory (m):</strong> Primary defense. Start at 64 MB, increase to 256 MB+ if possible</li>
                        <li><strong>Time (t):</strong> Number of passes. 3-4 iterations typical, increase if memory-limited</li>
                        <li><strong>Parallelism (p):</strong> Match CPU cores (4-8). Higher parallelism increases throughput</li>
                        <li><strong>Target:</strong> Aim for 200-500ms on production hardware</li>
                    </ul>
                </div>

                <div class="alert-box success">
                    <div class="alert-icon">‚úì</div>
                    <div class="alert-content">
                        <h4>When to Use Each Variant</h4>
                        <p>
                            <strong>Argon2id (recommended):</strong> Default choice for password hashing<br>
                            <strong>Argon2i:</strong> Only if side-channel attacks are a concern (shared hosting, VMs)<br>
                            <strong>Argon2d:</strong> Only for cryptocurrency or when maximum GPU resistance needed
                        </p>
                    </div>
                </div>

                <div class="code-block">
                    <pre>
# Python example (argon2-cffi)
from argon2 import PasswordHasher

ph = PasswordHasher(
    time_cost=3,        # Iterations
    memory_cost=65536,  # 64 MB
    parallelism=4,      # Threads
    hash_len=32,        # Output length
    salt_len=16         # Salt length
)

hash = ph.hash(password)
is_valid = ph.verify(hash, password)

# Automatic rehashing if parameters outdated
try:
    ph.verify(hash, password)
    if ph.check_needs_rehash(hash):
        new_hash = ph.hash(password)
        database.update(user, new_hash)
except:
    pass  # Invalid password</pre>
                </div>

                <div class="info-card">
                    <h3><span class="card-icon">üî¨</span>Argon2 Advantages</h3>
                    <ul class="custom-list">
                        <li><strong>Memory-hard:</strong> Configurable memory usage defeats GPU/ASIC attacks</li>
                        <li><strong>Parallelizable:</strong> Leverages multi-core CPUs for legitimate users</li>
                        <li><strong>Side-channel resistant:</strong> Argon2i/id variants defend against timing attacks</li>
                        <li><strong>Peer-reviewed:</strong> Won PHC after extensive cryptanalysis</li>
                        <li><strong>Future-proof:</strong> Three tuning parameters adapt to hardware evolution</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Section 8: Comparison -->
        <section class="content-section">
            <div class="section-header">
                <div class="section-icon">‚öñÔ∏è</div>
                <h2>KDF Comparison: When to Use Which</h2>
            </div>
            <div class="section-content">
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Algorithm</th>
                            <th>Year</th>
                            <th>Memory-Hard</th>
                            <th>GPU Resistance</th>
                            <th>Best Use Case</th>
                            <th>Limitations</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>PBKDF2</strong></td>
                            <td>2000</td>
                            <td>No</td>
                            <td>Low</td>
                            <td>Legacy systems, FIPS compliance</td>
                            <td>Requires very high iterations (600k+)</td>
                        </tr>
                        <tr>
                            <td><strong>bcrypt</strong></td>
                            <td>1999</td>
                            <td>No</td>
                            <td>Medium</td>
                            <td>Web apps, general password storage</td>
                            <td>72-byte password limit, max cost=31</td>
                        </tr>
                        <tr>
                            <td><strong>scrypt</strong></td>
                            <td>2009</td>
                            <td>Yes</td>
                            <td>High</td>
                            <td>File encryption, cryptocurrency</td>
                            <td>High memory can cause issues under load</td>
                        </tr>
                        <tr>
                            <td><strong>Argon2</strong></td>
                            <td>2015</td>
                            <td>Yes</td>
                            <td>Highest</td>
                            <td>New systems, high-security applications</td>
                            <td>Newer, less widespread library support</td>
                        </tr>
                    </tbody>
                </table>

                <div class="info-card">
                    <h3><span class="card-icon">üìä</span>Security vs Performance Trade-offs</h3>
                    <div class="code-block">
                        <pre>
# Attack costs (approximate, 2024 hardware)

Algorithm       | Time/Hash | Hashes/sec | Cost/Billion Guesses
----------------|-----------|------------|-----------------------
SHA256          | 0.00001ms | 100B       | $0.01 (trivial)
PBKDF2 (600k)   | 100ms     | 10         | $10,000
bcrypt (cost 12)| 250ms     | 4          | $25,000
scrypt (N=2^16) | 300ms     | 3          | $33,000
Argon2id (64MB) | 400ms     | 2.5        | $40,000

Note: GPU cluster costs, not single machines. Shows relative difficulty.</pre>
                    </div>
                </div>

                <div class="alert-box info">
                    <div class="alert-icon">üí°</div>
                    <div class="alert-content">
                        <h4>Decision Framework</h4>
                        <p>
                            <strong>New project?</strong> Use Argon2id<br>
                            <strong>Need FIPS compliance?</strong> Use PBKDF2 with 600k+ iterations<br>
                            <strong>Simple password hashing?</strong> bcrypt (cost 12) is battle-tested<br>
                            <strong>File/disk encryption?</strong> scrypt or Argon2<br>
                            <strong>Blockchain/cryptocurrency?</strong> scrypt or Argon2d
                        </p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 9: Real-World Usage -->
        <section class="content-section">
            <div class="section-header">
                <div class="section-icon">üåç</div>
                <h2>Real-World Applications</h2>
            </div>
            <div class="section-content">
                <div class="param-grid">
                    <div class="param-card">
                        <div class="param-name">Password Storage</div>
                        <div class="param-desc">
                            Web applications hash passwords before database storage. Django (PBKDF2),
                            Rails (bcrypt), and modern frameworks (Argon2) all use KDFs to protect credentials.
                        </div>
                    </div>
                    <div class="param-card">
                        <div class="param-name">Encryption Key Derivation</div>
                        <div class="param-desc">
                            Derive AES keys from user passwords for file encryption. Tools like VeraCrypt,
                            age, and 7-Zip use KDFs to transform passphrases into 256-bit keys.
                        </div>
                    </div>
                    <div class="param-card">
                        <div class="param-name">Cryptocurrency Wallets</div>
                        <div class="param-desc">
                            Bitcoin BIP-39 uses PBKDF2 to derive wallet keys from mnemonic phrases. Ethereum
                            keystore files use scrypt to protect private keys.
                        </div>
                    </div>
                    <div class="param-card">
                        <div class="param-name">API Key Management</div>
                        <div class="param-desc">
                            Hash API keys before storage (same as passwords). Prevents exposure in database breaches
                            and logs. Use bcrypt or Argon2 with lower work factors.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <pre>
# Example: Deriving encryption key from password
from argon2.low_level import hash_secret_raw
import os

# User provides password
password = "correct-horse-battery-staple"
salt = os.urandom(16)  # Store this with encrypted file

# Derive 256-bit key for AES-256
aes_key = hash_secret_raw(
    secret=password.encode(),
    salt=salt,
    time_cost=3,
    memory_cost=65536,
    parallelism=4,
    hash_len=32,    # 256 bits
    type=Type.ID
)

# Use aes_key for encryption
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
cipher = Cipher(algorithms.AES(aes_key), modes.GCM(iv))
# ... encrypt data ...</pre>
                </div>

                <div class="info-card">
                    <h3><span class="card-icon">üîê</span>Production Implementation Checklist</h3>
                    <ul class="custom-list">
                        <li>Generate cryptographically secure random salt (16+ bytes)</li>
                        <li>Store salt alongside hash (not secret, just unique)</li>
                        <li>Choose work factor based on performance testing on production hardware</li>
                        <li>Monitor authentication latency‚Äîusers tolerate 100-500ms, not 5 seconds</li>
                        <li>Plan for parameter upgrades (rehash on successful login if outdated)</li>
                        <li>Never truncate or modify user password before hashing (except for bcrypt workarounds)</li>
                        <li>Use constant-time comparison for hash verification (prevent timing attacks)</li>
                        <li>Rate-limit login attempts (KDFs slow brute force, not online guessing)</li>
                    </ul>
                </div>

                <div class="alert-box success">
                    <div class="alert-icon">‚úì</div>
                    <div class="alert-content">
                        <h4>Migration Strategy</h4>
                        <p>
                            Upgrading from weak to strong hashing without forcing password resets:
                        </p>
                        <div class="code-block">
                            <pre>
# Lazy migration pattern
function authenticate(username, password) {
    user = database.get(username);

    // Check current hash algorithm
    if (user.hash.startsWith('$2b$')) {
        // bcrypt - check cost factor
        if (bcrypt.verify(password, user.hash)) {
            if (bcrypt.getCost(user.hash) < 12) {
                // Upgrade to higher cost
                user.hash = bcrypt.hash(password, 12);
                database.update(user);
            }
            return true;
        }
    } else if (user.hash.startsWith('pbkdf2_')) {
        // Old PBKDF2 - migrate to Argon2
        if (pbkdf2.verify(password, user.hash)) {
            user.hash = argon2.hash(password);
            database.update(user);
            return true;
        }
    }
    return false;
}</pre>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 10: Common Mistakes -->
        <section class="content-section">
            <div class="section-header">
                <div class="section-icon">üö®</div>
                <h2>Common Mistakes and Vulnerabilities</h2>
            </div>
            <div class="section-content">
                <div class="alert-box warning">
                    <div class="alert-icon">‚ö†Ô∏è</div>
                    <div class="alert-content">
                        <h4>1. Using Fast Hash Functions for Passwords</h4>
                        <p>
                            MD5, SHA1, SHA256 without KDF are completely broken for password storage.
                            Billions of hashes per second on modern hardware make brute-force trivial.
                        </p>
                        <div class="code-block">
                            <pre>
# NEVER DO THIS
password_hash = SHA256(password)  ‚ùå Broken
password_hash = MD5(password + salt)  ‚ùå Still broken

# CORRECT
password_hash = argon2.hash(password)  ‚úì</pre>
                        </div>
                    </div>
                </div>

                <div class="alert-box warning">
                    <div class="alert-icon">‚ö†Ô∏è</div>
                    <div class="alert-content">
                        <h4>2. Insufficient Work Factors</h4>
                        <p>
                            Legacy systems with PBKDF2(1000) or bcrypt(cost=4) offer almost no protection.
                            Always benchmark and use current recommendations.
                        </p>
                        <div class="code-block">
                            <pre>
# WEAK - Old defaults
PBKDF2-HMAC-SHA256, 1000 iterations  ‚ùå (2005 level)
bcrypt cost=6                         ‚ùå (~0.5ms, too fast)

# STRONG - Current minimums
PBKDF2-HMAC-SHA256, 600,000 iterations  ‚úì
bcrypt cost=12                          ‚úì
Argon2id m=64MB, t=3, p=4              ‚úì</pre>
                        </div>
                    </div>
                </div>

                <div class="alert-box warning">
                    <div class="alert-icon">‚ö†Ô∏è</div>
                    <div class="alert-content">
                        <h4>3. No Salt or Reused Salt</h4>
                        <p>
                            Without unique salts, identical passwords produce identical hashes, enabling
                            rainbow tables and revealing password reuse patterns.
                        </p>
                        <div class="code-block">
                            <pre>
# WRONG - Same salt for all users
global_salt = "my_app_secret"
hash = bcrypt.hash(password + global_salt)  ‚ùå

# CORRECT - Unique salt per password
salt = os.urandom(16)  # Cryptographically random
hash = argon2.hash(password)  # Auto-generates unique salt  ‚úì</pre>
                        </div>
                    </div>
                </div>

                <div class="alert-box warning">
                    <div class="alert-icon">‚ö†Ô∏è</div>
                    <div class="alert-content">
                        <h4>4. Treating Salt as Secret</h4>
                        <p>
                            Salt doesn't need to be secret‚Äîits purpose is uniqueness, not confidentiality.
                            Storing it alongside the hash is correct. Using secret "pepper" is a separate concern.
                        </p>
                    </div>
                </div>

                <div class="alert-box warning">
                    <div class="alert-icon">‚ö†Ô∏è</div>
                    <div class="alert-content">
                        <h4>5. Rolling Your Own KDF</h4>
                        <p>
                            "for(i=0; i&lt;1000; i++) { hash = SHA256(hash) }" is not a KDF. Use proven algorithms.
                            Cryptography is hard; subtle mistakes are catastrophic.
                        </p>
                    </div>
                </div>

                <div class="info-card">
                    <h3><span class="card-icon">üéØ</span>Security Checklist</h3>
                    <ul class="custom-list">
                        <li>Use modern KDF: Argon2 > scrypt > bcrypt > PBKDF2 (never plain hash)</li>
                        <li>Work factor targets 100-500ms on your production hardware</li>
                        <li>Generate unique random salt (16+ bytes) for every password</li>
                        <li>Store salt in plaintext alongside hash</li>
                        <li>Plan for parameter increases (rehash on login if outdated)</li>
                        <li>Rate-limit authentication attempts (KDF ‚â† brute-force protection)</li>
                        <li>Use constant-time comparison for verification</li>
                        <li>Monitor and log suspicious authentication patterns</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Completion Section -->
        <section class="complete-section">
            <h2>Module Complete</h2>
            <p style="color: var(--text-secondary); margin: 20px 0;">
                You've mastered the fundamentals of Key Derivation Functions. You understand why KDFs matter,
                how salt prevents rainbow tables, and when to use PBKDF2, bcrypt, scrypt, or Argon2.
            </p>
            <button class="complete-btn" onclick="completeModule()">Mark Module as Complete</button>
            <p id="completion-message" style="margin-top: 20px; color: var(--success-green); display: none;">
                Module completed! Progress saved.
            </p>
        </section>
    </main>

    <script>
        // Scroll progress tracking
        window.addEventListener('scroll', () => {
            const windowHeight = window.innerHeight;
            const documentHeight = document.documentElement.scrollHeight - windowHeight;
            const scrolled = window.scrollY;
            const progress = (scrolled / documentHeight) * 100;

            document.getElementById('progress-fill').style.width = progress + '%';
            document.getElementById('scroll-progress').textContent = Math.round(progress) + '%';
        });

        // Module completion
        function completeModule() {
            const btn = document.querySelector('.complete-btn');
            btn.disabled = true;
            btn.textContent = 'Completing...';

            // Mark module as complete
            if (typeof ModuleProgress !== 'undefined') {
                ModuleProgress.complete('key', 'key-derivation');
            }

            // Show success message
            setTimeout(() => {
                btn.textContent = 'Completed!';
                document.getElementById('completion-message').style.display = 'block';

                // Optionally redirect back to house
                setTimeout(() => {
                    window.location.href = '../../index.html';
                }, 2000);
            }, 500);
        }

        // Track achievement for viewing presentation
        if (typeof AchievementManager !== 'undefined') {
            AchievementManager.unlock('student', 'Studied Key Derivation Functions');
        }
    </script>
<script src="../../../components/FluxCapacitor.js"></script>
</body>
</html>
