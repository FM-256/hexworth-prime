<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Topology Visualizer - Interactive Learning Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            color: #333;
        }

        .header {
            background: rgba(0,0,0,0.3);
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            color: white;
            font-size: 1.8em;
        }

        .home-btn {
            padding: 10px 20px;
            background: rgba(255,255,255,0.2);
            border: 2px solid white;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s;
            text-decoration: none;
        }

        .home-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .container {
            max-width: 1400px;
            margin: 20px auto;
            padding: 0 20px;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 0;
        }

        .tab {
            padding: 15px 25px;
            background: rgba(255,255,255,0.8);
            border: none;
            border-radius: 12px 12px 0 0;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            color: #666;
            transition: all 0.3s;
        }

        .tab:hover {
            background: rgba(255,255,255,0.95);
            color: #333;
        }

        .tab.active {
            background: white;
            color: #2a5298;
        }

        .tab-content {
            display: none;
            background: white;
            border-radius: 0 15px 15px 15px;
            padding: 30px;
            min-height: 600px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }

        .tab-content.active {
            display: block;
        }

        /* Topology Builder Tab */
        .builder-container {
            display: grid;
            grid-template-columns: 250px 1fr 300px;
            gap: 20px;
            min-height: 550px;
        }

        .toolbar {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
        }

        .toolbar h3 {
            color: #2a5298;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #2a5298;
        }

        .topology-presets {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }

        .preset-btn {
            padding: 12px 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95em;
            transition: all 0.3s;
            text-align: left;
        }

        .preset-btn:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .preset-btn.active {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .canvas-container {
            background: #f0f4f8;
            border-radius: 12px;
            position: relative;
            overflow: hidden;
        }

        #topology-canvas {
            width: 100%;
            height: 100%;
            min-height: 500px;
        }

        .info-panel {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
        }

        .info-panel h3 {
            color: #2a5298;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #2a5298;
        }

        .info-card {
            background: white;
            border-left: 4px solid #2a5298;
            padding: 15px;
            border-radius: 0 8px 8px 0;
            margin-bottom: 15px;
        }

        .info-card h4 {
            color: #2a5298;
            margin-bottom: 8px;
        }

        .info-card p {
            font-size: 0.95em;
            line-height: 1.6;
            color: #555;
        }

        .info-card.pros {
            border-left-color: #27ae60;
        }

        .info-card.pros h4 {
            color: #27ae60;
        }

        .info-card.cons {
            border-left-color: #e74c3c;
        }

        .info-card.cons h4 {
            color: #e74c3c;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }

        .stat-label {
            color: #666;
        }

        .stat-value {
            font-weight: bold;
            color: #2a5298;
        }

        /* Comparison Tab */
        .comparison-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 20px;
        }

        .topology-card {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s;
            cursor: pointer;
            border: 3px solid transparent;
        }

        .topology-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
        }

        .topology-card.selected {
            border-color: #2a5298;
            background: #e8f4ff;
        }

        .topology-card svg {
            width: 150px;
            height: 120px;
            margin-bottom: 15px;
        }

        .topology-card h4 {
            color: #2a5298;
            margin-bottom: 10px;
        }

        .topology-card p {
            font-size: 0.9em;
            color: #666;
        }

        .comparison-table-container {
            margin-top: 30px;
            overflow-x: auto;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95em;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .comparison-table th {
            background: #2a5298;
            color: white;
            position: sticky;
            top: 0;
        }

        .comparison-table tr:hover {
            background: #f5f5f5;
        }

        .comparison-table .highlight {
            background: #e8f4ff;
        }

        .rating {
            display: flex;
            gap: 3px;
        }

        .rating-star {
            color: #f39c12;
        }

        .rating-star.empty {
            color: #ddd;
        }

        /* Calculator Tab */
        .calculator-container {
            max-width: 800px;
            margin: 0 auto;
        }

        .calc-section {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
        }

        .calc-section h3 {
            color: #2a5298;
            margin-bottom: 20px;
        }

        .calc-input-group {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .calc-input-group label {
            font-weight: bold;
            min-width: 150px;
        }

        .calc-input-group input {
            padding: 12px 15px;
            font-size: 1.2em;
            border: 2px solid #ddd;
            border-radius: 8px;
            width: 150px;
            text-align: center;
        }

        .calc-input-group input:focus {
            border-color: #2a5298;
            outline: none;
        }

        .calc-result {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 12px;
            text-align: center;
        }

        .calc-result h4 {
            font-size: 1.1em;
            margin-bottom: 10px;
        }

        .calc-result .big-number {
            font-size: 3em;
            font-weight: bold;
        }

        .calc-formula {
            background: #2a5298;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 1.2em;
            text-align: center;
            margin: 20px 0;
        }

        .calc-examples {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .calc-example {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #eee;
        }

        .calc-example:hover {
            border-color: #2a5298;
        }

        .calc-example .devices {
            font-size: 1.5em;
            font-weight: bold;
            color: #2a5298;
        }

        .calc-example .connections {
            font-size: 0.9em;
            color: #666;
        }

        /* Quiz Tab */
        .quiz-container {
            max-width: 900px;
            margin: 0 auto;
        }

        .quiz-progress {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding: 15px 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .progress-bar {
            flex: 1;
            height: 10px;
            background: #ddd;
            border-radius: 5px;
            margin: 0 20px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #27ae60, #2ecc71);
            border-radius: 5px;
            transition: width 0.3s;
        }

        .quiz-question-container {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
        }

        .quiz-question {
            font-size: 1.3em;
            color: #2a5298;
            margin-bottom: 25px;
            line-height: 1.5;
        }

        .quiz-image {
            text-align: center;
            margin: 20px 0;
        }

        .quiz-image svg {
            max-width: 300px;
            height: auto;
        }

        .quiz-options {
            display: grid;
            gap: 12px;
        }

        .quiz-option {
            padding: 15px 20px;
            background: white;
            border: 2px solid #ddd;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1.05em;
        }

        .quiz-option:hover:not(.disabled) {
            border-color: #2a5298;
            background: #f0f4ff;
        }

        .quiz-option.selected {
            border-color: #2a5298;
            background: #e8f4ff;
        }

        .quiz-option.correct {
            border-color: #27ae60;
            background: #e8f8f0;
        }

        .quiz-option.incorrect {
            border-color: #e74c3c;
            background: #fdf2f2;
        }

        .quiz-option.disabled {
            cursor: default;
        }

        .quiz-feedback {
            margin-top: 20px;
            padding: 20px;
            border-radius: 10px;
            display: none;
        }

        .quiz-feedback.show {
            display: block;
        }

        .quiz-feedback.correct {
            background: #e8f8f0;
            border-left: 5px solid #27ae60;
        }

        .quiz-feedback.incorrect {
            background: #fdf2f2;
            border-left: 5px solid #e74c3c;
        }

        .quiz-btn {
            padding: 15px 30px;
            font-size: 1.1em;
            background: #2a5298;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .quiz-btn:hover {
            background: #1e3c72;
        }

        .quiz-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .quiz-results {
            text-align: center;
            padding: 40px;
        }

        .quiz-score {
            font-size: 4em;
            font-weight: bold;
            color: #2a5298;
            margin-bottom: 20px;
        }

        .quiz-score.excellent {
            color: #27ae60;
        }

        .quiz-score.good {
            color: #f39c12;
        }

        .quiz-score.needs-work {
            color: #e74c3c;
        }

        /* Animation Tab */
        .animation-container {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
        }

        .animation-canvas {
            background: #f0f4f8;
            border-radius: 12px;
            min-height: 450px;
            position: relative;
            overflow: hidden;
        }

        .animation-controls {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
        }

        .animation-controls h3 {
            color: #2a5298;
            margin-bottom: 15px;
        }

        .scenario-select {
            width: 100%;
            padding: 12px;
            font-size: 1em;
            border: 2px solid #ddd;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .control-btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            background: #2a5298;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s;
        }

        .control-btn:hover {
            background: #1e3c72;
        }

        .control-btn.secondary {
            background: #6c757d;
        }

        .animation-status {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }

        .status-item:last-child {
            border-bottom: none;
        }

        .packet {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #e74c3c;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 10px rgba(231, 76, 60, 0.5);
            z-index: 100;
        }

        .packet::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: inherit;
            border-radius: inherit;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .builder-container {
                grid-template-columns: 200px 1fr;
            }
            .info-panel {
                display: none;
            }
            .comparison-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            .animation-container {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .tabs {
                flex-wrap: wrap;
            }
            .tab {
                flex: 1;
                text-align: center;
                font-size: 0.9em;
                padding: 12px 15px;
            }
            .builder-container {
                grid-template-columns: 1fr;
            }
            .comparison-grid {
                grid-template-columns: 1fr;
            }
            .calc-examples {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Network Topology Visualizer</h1>
        <a href="../../index.html" class="home-btn">Back to Catalog</a>
    </div>

    <div class="container">
        <div class="tabs">
            <button class="tab active" onclick="switchTab('builder')">Topology Builder</button>
            <button class="tab" onclick="switchTab('comparison')">Compare Topologies</button>
            <button class="tab" onclick="switchTab('calculator')">Mesh Calculator</button>
            <button class="tab" onclick="switchTab('animation')">Traffic Animation</button>
            <button class="tab" onclick="switchTab('quiz')">Knowledge Quiz</button>
        </div>

        <!-- Tab 1: Topology Builder -->
        <div id="builder" class="tab-content active">
            <div class="builder-container">
                <div class="toolbar">
                    <h3>Select Topology</h3>
                    <div class="topology-presets">
                        <button class="preset-btn active" onclick="loadTopology('star')">
                            Star Topology
                        </button>
                        <button class="preset-btn" onclick="loadTopology('extended-star')">
                            Extended Star
                        </button>
                        <button class="preset-btn" onclick="loadTopology('bus')">
                            Bus Topology
                        </button>
                        <button class="preset-btn" onclick="loadTopology('ring')">
                            Ring Topology
                        </button>
                        <button class="preset-btn" onclick="loadTopology('full-mesh')">
                            Full Mesh
                        </button>
                        <button class="preset-btn" onclick="loadTopology('partial-mesh')">
                            Partial Mesh
                        </button>
                        <button class="preset-btn" onclick="loadTopology('hybrid')">
                            Hybrid (Star-Mesh)
                        </button>
                        <button class="preset-btn" onclick="loadTopology('spine-leaf')">
                            Spine-Leaf
                        </button>
                    </div>

                    <h3 style="margin-top: 20px;">Device Count</h3>
                    <div style="display: flex; align-items: center; gap: 10px; margin-top: 10px;">
                        <input type="range" id="device-slider" min="3" max="8" value="5"
                               onchange="updateDeviceCount(this.value)" style="flex: 1;">
                        <span id="device-count-display" style="font-weight: bold; color: #2a5298;">5</span>
                    </div>
                </div>

                <div class="canvas-container">
                    <svg id="topology-canvas" viewBox="0 0 600 500"></svg>
                </div>

                <div class="info-panel">
                    <h3 id="topology-name">Star Topology</h3>

                    <div class="info-card">
                        <h4>Description</h4>
                        <p id="topology-description">All devices connect to a central device (switch or hub). Most common topology in modern LANs.</p>
                    </div>

                    <div class="info-card pros">
                        <h4>Advantages</h4>
                        <ul id="topology-pros">
                            <li>Easy to install and manage</li>
                            <li>Fault isolation - one failure doesn't affect others</li>
                            <li>Easy to add new devices</li>
                        </ul>
                    </div>

                    <div class="info-card cons">
                        <h4>Disadvantages</h4>
                        <ul id="topology-cons">
                            <li>Central device is single point of failure</li>
                            <li>Requires more cabling than bus</li>
                        </ul>
                    </div>

                    <h3 style="margin-top: 20px;">Statistics</h3>
                    <div class="stat-row">
                        <span class="stat-label">Devices:</span>
                        <span class="stat-value" id="stat-devices">6</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Connections:</span>
                        <span class="stat-value" id="stat-connections">5</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Redundancy:</span>
                        <span class="stat-value" id="stat-redundancy">Low</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Scalability:</span>
                        <span class="stat-value" id="stat-scalability">High</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tab 2: Comparison -->
        <div id="comparison" class="tab-content">
            <h2 style="color: #2a5298; margin-bottom: 20px;">Compare Network Topologies</h2>
            <p style="color: #666; margin-bottom: 20px;">Click on topologies to highlight them in the comparison table below.</p>

            <div class="comparison-grid">
                <div class="topology-card selected" onclick="toggleCompare(this, 'star')">
                    <svg viewBox="0 0 150 120">
                        <rect x="60" y="45" width="30" height="25" rx="3" fill="#e74c3c"/>
                        <circle cx="75" cy="15" r="12" fill="#3498db"/>
                        <circle cx="25" cy="45" r="12" fill="#3498db"/>
                        <circle cx="125" cy="45" r="12" fill="#3498db"/>
                        <circle cx="40" cy="100" r="12" fill="#3498db"/>
                        <circle cx="110" cy="100" r="12" fill="#3498db"/>
                        <line x1="75" y1="27" x2="75" y2="45" stroke="#2a5298" stroke-width="2"/>
                        <line x1="37" y1="45" x2="60" y2="55" stroke="#2a5298" stroke-width="2"/>
                        <line x1="113" y1="45" x2="90" y2="55" stroke="#2a5298" stroke-width="2"/>
                        <line x1="50" y1="92" x2="65" y2="70" stroke="#2a5298" stroke-width="2"/>
                        <line x1="100" y1="92" x2="85" y2="70" stroke="#2a5298" stroke-width="2"/>
                    </svg>
                    <h4>Star</h4>
                    <p>Central device connects all nodes</p>
                </div>

                <div class="topology-card" onclick="toggleCompare(this, 'bus')">
                    <svg viewBox="0 0 150 120">
                        <line x1="15" y1="60" x2="135" y2="60" stroke="#e74c3c" stroke-width="4"/>
                        <rect x="10" y="52" width="12" height="16" fill="#c0392b"/>
                        <rect x="128" y="52" width="12" height="16" fill="#c0392b"/>
                        <circle cx="40" cy="35" r="12" fill="#3498db"/>
                        <circle cx="75" cy="35" r="12" fill="#3498db"/>
                        <circle cx="110" cy="35" r="12" fill="#3498db"/>
                        <line x1="40" y1="47" x2="40" y2="60" stroke="#2a5298" stroke-width="2"/>
                        <line x1="75" y1="47" x2="75" y2="60" stroke="#2a5298" stroke-width="2"/>
                        <line x1="110" y1="47" x2="110" y2="60" stroke="#2a5298" stroke-width="2"/>
                    </svg>
                    <h4>Bus</h4>
                    <p>Single backbone cable</p>
                </div>

                <div class="topology-card" onclick="toggleCompare(this, 'ring')">
                    <svg viewBox="0 0 150 120">
                        <ellipse cx="75" cy="60" rx="50" ry="40" fill="none" stroke="#2a5298" stroke-width="2"/>
                        <circle cx="75" cy="20" r="12" fill="#3498db"/>
                        <circle cx="120" cy="50" r="12" fill="#3498db"/>
                        <circle cx="105" cy="95" r="12" fill="#3498db"/>
                        <circle cx="45" cy="95" r="12" fill="#3498db"/>
                        <circle cx="30" cy="50" r="12" fill="#3498db"/>
                    </svg>
                    <h4>Ring</h4>
                    <p>Circular data path</p>
                </div>

                <div class="topology-card" onclick="toggleCompare(this, 'full-mesh')">
                    <svg viewBox="0 0 150 120">
                        <line x1="75" y1="15" x2="125" y2="50" stroke="#2a5298" stroke-width="2"/>
                        <line x1="75" y1="15" x2="110" y2="100" stroke="#2a5298" stroke-width="2"/>
                        <line x1="75" y1="15" x2="40" y2="100" stroke="#2a5298" stroke-width="2"/>
                        <line x1="75" y1="15" x2="25" y2="50" stroke="#2a5298" stroke-width="2"/>
                        <line x1="125" y1="50" x2="110" y2="100" stroke="#2a5298" stroke-width="2"/>
                        <line x1="125" y1="50" x2="40" y2="100" stroke="#2a5298" stroke-width="2"/>
                        <line x1="125" y1="50" x2="25" y2="50" stroke="#2a5298" stroke-width="2"/>
                        <line x1="110" y1="100" x2="40" y2="100" stroke="#2a5298" stroke-width="2"/>
                        <line x1="110" y1="100" x2="25" y2="50" stroke="#2a5298" stroke-width="2"/>
                        <line x1="40" y1="100" x2="25" y2="50" stroke="#2a5298" stroke-width="2"/>
                        <circle cx="75" cy="15" r="10" fill="#3498db"/>
                        <circle cx="125" cy="50" r="10" fill="#3498db"/>
                        <circle cx="110" cy="100" r="10" fill="#3498db"/>
                        <circle cx="40" cy="100" r="10" fill="#3498db"/>
                        <circle cx="25" cy="50" r="10" fill="#3498db"/>
                    </svg>
                    <h4>Full Mesh</h4>
                    <p>Every device connected</p>
                </div>

                <div class="topology-card" onclick="toggleCompare(this, 'partial-mesh')">
                    <svg viewBox="0 0 150 120">
                        <line x1="75" y1="15" x2="125" y2="50" stroke="#2a5298" stroke-width="2"/>
                        <line x1="75" y1="15" x2="25" y2="50" stroke="#2a5298" stroke-width="2"/>
                        <line x1="125" y1="50" x2="110" y2="100" stroke="#2a5298" stroke-width="2"/>
                        <line x1="25" y1="50" x2="40" y2="100" stroke="#2a5298" stroke-width="2"/>
                        <line x1="110" y1="100" x2="40" y2="100" stroke="#2a5298" stroke-width="2"/>
                        <line x1="125" y1="50" x2="25" y2="50" stroke="#2a5298" stroke-width="2"/>
                        <circle cx="75" cy="15" r="10" fill="#3498db"/>
                        <circle cx="125" cy="50" r="10" fill="#3498db"/>
                        <circle cx="110" cy="100" r="10" fill="#3498db"/>
                        <circle cx="40" cy="100" r="10" fill="#3498db"/>
                        <circle cx="25" cy="50" r="10" fill="#3498db"/>
                    </svg>
                    <h4>Partial Mesh</h4>
                    <p>Strategic redundancy</p>
                </div>

                <div class="topology-card" onclick="toggleCompare(this, 'hybrid')">
                    <svg viewBox="0 0 150 120">
                        <rect x="60" y="10" width="30" height="20" rx="3" fill="#e74c3c"/>
                        <rect x="20" y="50" width="25" height="18" rx="3" fill="#9b59b6"/>
                        <rect x="105" y="50" width="25" height="18" rx="3" fill="#9b59b6"/>
                        <circle cx="20" cy="100" r="8" fill="#3498db"/>
                        <circle cx="50" cy="100" r="8" fill="#3498db"/>
                        <circle cx="100" cy="100" r="8" fill="#3498db"/>
                        <circle cx="130" cy="100" r="8" fill="#3498db"/>
                        <line x1="65" y1="30" x2="40" y2="50" stroke="#2a5298" stroke-width="2"/>
                        <line x1="85" y1="30" x2="110" y2="50" stroke="#2a5298" stroke-width="2"/>
                        <line x1="20" y1="68" x2="20" y2="92" stroke="#2a5298" stroke-width="2"/>
                        <line x1="45" y1="68" x2="50" y2="92" stroke="#2a5298" stroke-width="2"/>
                        <line x1="105" y1="68" x2="100" y2="92" stroke="#2a5298" stroke-width="2"/>
                        <line x1="130" y1="68" x2="130" y2="92" stroke="#2a5298" stroke-width="2"/>
                    </svg>
                    <h4>Hybrid</h4>
                    <p>Combined topologies</p>
                </div>
            </div>

            <div class="comparison-table-container">
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Characteristic</th>
                            <th>Star</th>
                            <th>Bus</th>
                            <th>Ring</th>
                            <th>Full Mesh</th>
                            <th>Partial Mesh</th>
                            <th>Hybrid</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Cost</strong></td>
                            <td class="highlight">Medium</td>
                            <td>Low</td>
                            <td>Medium</td>
                            <td>Very High</td>
                            <td>High</td>
                            <td>Varies</td>
                        </tr>
                        <tr>
                            <td><strong>Scalability</strong></td>
                            <td class="highlight"><div class="rating"><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star empty">★</span></div></td>
                            <td><div class="rating"><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star empty">★</span><span class="rating-star empty">★</span><span class="rating-star empty">★</span></div></td>
                            <td><div class="rating"><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star empty">★</span><span class="rating-star empty">★</span><span class="rating-star empty">★</span></div></td>
                            <td><div class="rating"><span class="rating-star">★</span><span class="rating-star empty">★</span><span class="rating-star empty">★</span><span class="rating-star empty">★</span><span class="rating-star empty">★</span></div></td>
                            <td><div class="rating"><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star empty">★</span><span class="rating-star empty">★</span></div></td>
                            <td><div class="rating"><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star">★</span></div></td>
                        </tr>
                        <tr>
                            <td><strong>Fault Tolerance</strong></td>
                            <td class="highlight"><div class="rating"><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star empty">★</span><span class="rating-star empty">★</span><span class="rating-star empty">★</span></div></td>
                            <td><div class="rating"><span class="rating-star">★</span><span class="rating-star empty">★</span><span class="rating-star empty">★</span><span class="rating-star empty">★</span><span class="rating-star empty">★</span></div></td>
                            <td><div class="rating"><span class="rating-star">★</span><span class="rating-star empty">★</span><span class="rating-star empty">★</span><span class="rating-star empty">★</span><span class="rating-star empty">★</span></div></td>
                            <td><div class="rating"><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star">★</span></div></td>
                            <td><div class="rating"><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star empty">★</span></div></td>
                            <td><div class="rating"><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star empty">★</span></div></td>
                        </tr>
                        <tr>
                            <td><strong>Ease of Management</strong></td>
                            <td class="highlight"><div class="rating"><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star empty">★</span></div></td>
                            <td><div class="rating"><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star empty">★</span><span class="rating-star empty">★</span><span class="rating-star empty">★</span></div></td>
                            <td><div class="rating"><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star empty">★</span><span class="rating-star empty">★</span><span class="rating-star empty">★</span></div></td>
                            <td><div class="rating"><span class="rating-star">★</span><span class="rating-star empty">★</span><span class="rating-star empty">★</span><span class="rating-star empty">★</span><span class="rating-star empty">★</span></div></td>
                            <td><div class="rating"><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star empty">★</span><span class="rating-star empty">★</span></div></td>
                            <td><div class="rating"><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star empty">★</span><span class="rating-star empty">★</span></div></td>
                        </tr>
                        <tr>
                            <td><strong>Single Point of Failure</strong></td>
                            <td class="highlight">Central device</td>
                            <td>Backbone cable</td>
                            <td>Any link/node</td>
                            <td>None</td>
                            <td>Depends</td>
                            <td>Varies</td>
                        </tr>
                        <tr>
                            <td><strong>Best Use Case</strong></td>
                            <td class="highlight">LAN, Office</td>
                            <td>Legacy only</td>
                            <td>FDDI, SONET</td>
                            <td>WAN Core</td>
                            <td>Distribution</td>
                            <td>Enterprise</td>
                        </tr>
                        <tr>
                            <td><strong>Cable Requirements</strong></td>
                            <td class="highlight">n cables</td>
                            <td>1 backbone</td>
                            <td>n cables</td>
                            <td>n(n-1)/2</td>
                            <td>Variable</td>
                            <td>Variable</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Tab 3: Mesh Calculator -->
        <div id="calculator" class="tab-content">
            <div class="calculator-container">
                <h2 style="color: #2a5298; margin-bottom: 10px;">Full Mesh Connection Calculator</h2>
                <p style="color: #666; margin-bottom: 30px;">Calculate how many connections are needed for a full mesh network.</p>

                <div class="calc-section">
                    <h3>The Formula</h3>
                    <div class="calc-formula">
                        Connections = n(n-1) / 2
                    </div>
                    <p style="text-align: center; color: #666;">Where <strong>n</strong> = number of devices in the network</p>
                </div>

                <div class="calc-section">
                    <h3>Calculate</h3>
                    <div class="calc-input-group">
                        <label for="mesh-devices">Number of Devices:</label>
                        <input type="number" id="mesh-devices" min="2" max="100" value="5" oninput="calculateMesh()">
                    </div>

                    <div class="calc-result">
                        <h4>Connections Required for Full Mesh:</h4>
                        <div class="big-number" id="mesh-result">10</div>
                        <p id="mesh-explanation">5 devices, each connected to 4 others = 20 links, but since each link is shared by 2 devices, we divide by 2.</p>
                    </div>
                </div>

                <div class="calc-section">
                    <h3>Quick Reference</h3>
                    <div class="calc-examples">
                        <div class="calc-example" onclick="setDevices(3)">
                            <div class="devices">3</div>
                            <div class="connections">3 connections</div>
                        </div>
                        <div class="calc-example" onclick="setDevices(4)">
                            <div class="devices">4</div>
                            <div class="connections">6 connections</div>
                        </div>
                        <div class="calc-example" onclick="setDevices(5)">
                            <div class="devices">5</div>
                            <div class="connections">10 connections</div>
                        </div>
                        <div class="calc-example" onclick="setDevices(6)">
                            <div class="devices">6</div>
                            <div class="connections">15 connections</div>
                        </div>
                        <div class="calc-example" onclick="setDevices(8)">
                            <div class="devices">8</div>
                            <div class="connections">28 connections</div>
                        </div>
                        <div class="calc-example" onclick="setDevices(10)">
                            <div class="devices">10</div>
                            <div class="connections">45 connections</div>
                        </div>
                        <div class="calc-example" onclick="setDevices(12)">
                            <div class="devices">12</div>
                            <div class="connections">66 connections</div>
                        </div>
                        <div class="calc-example" onclick="setDevices(20)">
                            <div class="devices">20</div>
                            <div class="connections">190 connections</div>
                        </div>
                    </div>
                </div>

                <div class="calc-section">
                    <h3>Why Full Mesh Doesn't Scale</h3>
                    <div style="background: #fdf2f2; border-left: 5px solid #e74c3c; padding: 15px; border-radius: 0 8px 8px 0;">
                        <p>Notice how connections grow <strong>exponentially</strong>! Going from 10 to 20 devices doesn't double the connections - it increases them from 45 to 190 (4x more!).</p>
                        <p style="margin-top: 10px;">This is why <strong>full mesh</strong> is only used for small, critical networks (like connecting 2-4 data centers), while <strong>partial mesh</strong> is used for larger deployments.</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tab 4: Traffic Animation -->
        <div id="animation" class="tab-content">
            <h2 style="color: #2a5298; margin-bottom: 20px;">Traffic Flow Animation</h2>
            <p style="color: #666; margin-bottom: 20px;">Watch how data travels through different topologies.</p>

            <div class="animation-container">
                <div class="animation-canvas">
                    <svg id="animation-svg" viewBox="0 0 600 450" style="width: 100%; height: 100%;"></svg>
                </div>

                <div class="animation-controls">
                    <h3>Topology</h3>
                    <select class="scenario-select" id="anim-topology" onchange="initAnimation()">
                        <option value="star">Star Topology</option>
                        <option value="bus">Bus Topology</option>
                        <option value="ring">Ring Topology</option>
                        <option value="mesh">Mesh Topology</option>
                    </select>

                    <h3>Scenario</h3>
                    <select class="scenario-select" id="anim-scenario" onchange="resetAnimation()">
                        <option value="unicast">Unicast (PC to PC)</option>
                        <option value="broadcast">Broadcast (All devices)</option>
                        <option value="failure">Link Failure Recovery</option>
                    </select>

                    <button class="control-btn" onclick="startAnimation()">
                        ▶ Start Animation
                    </button>
                    <button class="control-btn secondary" onclick="resetAnimation()">
                        ↺ Reset
                    </button>

                    <div class="animation-status">
                        <h4 style="margin-bottom: 10px;">Status</h4>
                        <div class="status-item">
                            <span>Source:</span>
                            <span id="status-source">PC1</span>
                        </div>
                        <div class="status-item">
                            <span>Destination:</span>
                            <span id="status-dest">PC3</span>
                        </div>
                        <div class="status-item">
                            <span>Hops:</span>
                            <span id="status-hops">2</span>
                        </div>
                        <div class="status-item">
                            <span>Path:</span>
                            <span id="status-path">PC1 → SW → PC3</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tab 5: Quiz -->
        <div id="quiz" class="tab-content">
            <div class="quiz-container">
                <div class="quiz-progress">
                    <span id="quiz-current">Question 1 of 10</span>
                    <div class="progress-bar">
                        <div class="progress-fill" id="quiz-progress-bar" style="width: 10%;"></div>
                    </div>
                    <span id="quiz-score-display">Score: 0/0</span>
                </div>

                <div id="quiz-question-area">
                    <!-- Questions will be dynamically inserted here -->
                </div>

                <div id="quiz-results" class="quiz-results" style="display: none;">
                    <h2>Quiz Complete!</h2>
                    <div class="quiz-score" id="final-score">8/10</div>
                    <p id="score-message">Great job! You have a solid understanding of network topologies.</p>
                    <button class="quiz-btn" onclick="restartQuiz()" style="margin-top: 20px;">
                        Try Again
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===============================
        // TAB SWITCHING
        // ===============================
        function switchTab(tabId) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

            event.target.classList.add('active');
            document.getElementById(tabId).classList.add('active');

            if (tabId === 'animation') {
                initAnimation();
            }
            if (tabId === 'quiz' && !quizStarted) {
                startQuiz();
            }
        }

        // ===============================
        // TOPOLOGY BUILDER
        // ===============================
        const topologyData = {
            'star': {
                name: 'Star Topology',
                description: 'All devices connect to a central device (switch or hub). Most common topology in modern LANs.',
                pros: ['Easy to install and manage', 'Fault isolation - one failure doesn\'t affect others', 'Easy to add new devices', 'Simple troubleshooting'],
                cons: ['Central device is single point of failure', 'Requires more cabling than bus', 'Performance depends on central device'],
                redundancy: 'Low',
                scalability: 'High'
            },
            'extended-star': {
                name: 'Extended Star (Hub-and-Spoke)',
                description: 'Multiple star topologies connected together. Common in enterprise networks with access, distribution, and core layers.',
                pros: ['Highly scalable', 'Hierarchical management', 'Good for large networks', 'Can add redundancy at higher tiers'],
                cons: ['More complex than simple star', 'Core switches become critical', 'Higher cost'],
                redundancy: 'Medium',
                scalability: 'Very High'
            },
            'bus': {
                name: 'Bus Topology',
                description: 'All devices connect to a single backbone cable. Legacy technology using coaxial cable (10BASE2, 10BASE5).',
                pros: ['Simple design', 'Low cost - less cabling', 'Easy to extend'],
                cons: ['Single point of failure (backbone)', 'Difficult to troubleshoot', 'Performance degrades with more devices', 'Requires terminators'],
                redundancy: 'None',
                scalability: 'Poor'
            },
            'ring': {
                name: 'Ring Topology',
                description: 'Each device connects to exactly two neighbors forming a circle. Uses token passing for media access (Token Ring, FDDI).',
                pros: ['No collisions (token passing)', 'Predictable performance', 'Equal access for all devices'],
                cons: ['One break takes down network', 'Difficult to troubleshoot', 'Adding devices disrupts network'],
                redundancy: 'None (Single Ring)',
                scalability: 'Fair'
            },
            'full-mesh': {
                name: 'Full Mesh Topology',
                description: 'Every device has a direct connection to every other device. Maximum redundancy but highest cost.',
                pros: ['Maximum redundancy', 'No single point of failure', 'Multiple paths for load balancing', 'Best fault tolerance'],
                cons: ['Very expensive', 'Complex to manage', 'Doesn\'t scale (n(n-1)/2 connections)', 'Wiring complexity'],
                redundancy: 'Maximum',
                scalability: 'Poor'
            },
            'partial-mesh': {
                name: 'Partial Mesh Topology',
                description: 'Some devices have multiple connections, others have fewer. Balances redundancy with cost.',
                pros: ['Good redundancy for critical paths', 'More cost-effective than full mesh', 'Flexible design'],
                cons: ['Some single points of failure may exist', 'Requires careful planning', 'More complex than star'],
                redundancy: 'Good',
                scalability: 'Good'
            },
            'hybrid': {
                name: 'Hybrid Topology (Star-Mesh)',
                description: 'Combines star at access layer with mesh at core/distribution. Real-world enterprise design.',
                pros: ['Best of multiple topologies', 'Scalable', 'Redundancy where needed', 'Cost-effective'],
                cons: ['More complex to design', 'Requires expertise', 'Variable costs'],
                redundancy: 'Customizable',
                scalability: 'Excellent'
            },
            'spine-leaf': {
                name: 'Spine-Leaf Topology',
                description: 'Data center design where every leaf switch connects to every spine switch. Optimized for East-West traffic.',
                pros: ['Predictable latency (max 2 hops)', 'Easy to scale', 'No STP needed (uses ECMP)', 'Optimal for server-to-server traffic'],
                cons: ['Requires specific hardware', 'More complex routing', 'Higher initial cost'],
                redundancy: 'High',
                scalability: 'Excellent'
            }
        };

        let currentTopology = 'star';
        let deviceCount = 5;

        function loadTopology(type) {
            currentTopology = type;

            // Update button states
            document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            // Update info panel
            const data = topologyData[type];
            document.getElementById('topology-name').textContent = data.name;
            document.getElementById('topology-description').textContent = data.description;

            const prosHtml = data.pros.map(p => `<li>${p}</li>`).join('');
            document.getElementById('topology-pros').innerHTML = prosHtml;

            const consHtml = data.cons.map(c => `<li>${c}</li>`).join('');
            document.getElementById('topology-cons').innerHTML = consHtml;

            document.getElementById('stat-redundancy').textContent = data.redundancy;
            document.getElementById('stat-scalability').textContent = data.scalability;

            drawTopology();
        }

        function updateDeviceCount(count) {
            deviceCount = parseInt(count);
            document.getElementById('device-count-display').textContent = count;
            drawTopology();
        }

        function drawTopology() {
            const canvas = document.getElementById('topology-canvas');
            const width = 600;
            const height = 500;
            const centerX = width / 2;
            const centerY = height / 2;

            let svg = '';
            let connections = 0;
            let totalDevices = deviceCount;

            switch(currentTopology) {
                case 'star':
                    svg = drawStar(centerX, centerY, deviceCount);
                    connections = deviceCount;
                    totalDevices = deviceCount + 1;
                    break;
                case 'extended-star':
                    svg = drawExtendedStar(centerX, centerY);
                    connections = 8;
                    totalDevices = 9;
                    break;
                case 'bus':
                    svg = drawBus(centerX, centerY, deviceCount);
                    connections = deviceCount;
                    break;
                case 'ring':
                    svg = drawRing(centerX, centerY, deviceCount);
                    connections = deviceCount;
                    break;
                case 'full-mesh':
                    svg = drawFullMesh(centerX, centerY, deviceCount);
                    connections = (deviceCount * (deviceCount - 1)) / 2;
                    break;
                case 'partial-mesh':
                    svg = drawPartialMesh(centerX, centerY, deviceCount);
                    connections = deviceCount + 2;
                    break;
                case 'hybrid':
                    svg = drawHybrid(centerX, centerY);
                    connections = 10;
                    totalDevices = 9;
                    break;
                case 'spine-leaf':
                    svg = drawSpineLeaf(centerX, centerY);
                    connections = 12;
                    totalDevices = 11;
                    break;
            }

            canvas.innerHTML = svg;
            document.getElementById('stat-devices').textContent = totalDevices;
            document.getElementById('stat-connections').textContent = connections;
        }

        function drawStar(cx, cy, count) {
            let svg = '';
            const radius = 180;

            // Central switch
            svg += `<rect x="${cx-30}" y="${cy-20}" width="60" height="40" rx="5" fill="#e74c3c" stroke="#c0392b" stroke-width="2"/>`;
            svg += `<text x="${cx}" y="${cy+5}" text-anchor="middle" fill="white" font-size="14" font-weight="bold">Switch</text>`;

            // Devices around
            for (let i = 0; i < count; i++) {
                const angle = (i * 2 * Math.PI / count) - Math.PI/2;
                const x = cx + radius * Math.cos(angle);
                const y = cy + radius * Math.sin(angle);

                svg += `<line x1="${cx}" y1="${cy}" x2="${x}" y2="${y}" stroke="#2a5298" stroke-width="3"/>`;
                svg += `<circle cx="${x}" cy="${y}" r="25" fill="#3498db" stroke="#2980b9" stroke-width="2"/>`;
                svg += `<text x="${x}" y="${y+5}" text-anchor="middle" fill="white" font-size="12" font-weight="bold">PC${i+1}</text>`;
            }

            return svg;
        }

        function drawExtendedStar(cx, cy) {
            let svg = '';

            // Core switch
            svg += `<rect x="${cx-35}" y="40" width="70" height="40" rx="5" fill="#e74c3c" stroke="#c0392b" stroke-width="2"/>`;
            svg += `<text x="${cx}" y="65" text-anchor="middle" fill="white" font-size="12" font-weight="bold">Core</text>`;

            // Distribution switches
            svg += `<rect x="100" y="150" width="60" height="35" rx="4" fill="#9b59b6" stroke="#8e44ad" stroke-width="2"/>`;
            svg += `<text x="130" y="172" text-anchor="middle" fill="white" font-size="11" font-weight="bold">Dist1</text>`;

            svg += `<rect x="440" y="150" width="60" height="35" rx="4" fill="#9b59b6" stroke="#8e44ad" stroke-width="2"/>`;
            svg += `<text x="470" y="172" text-anchor="middle" fill="white" font-size="11" font-weight="bold">Dist2</text>`;

            // Core to Distribution links
            svg += `<line x1="${cx}" y1="80" x2="130" y2="150" stroke="#2a5298" stroke-width="3"/>`;
            svg += `<line x1="${cx}" y1="80" x2="470" y2="150" stroke="#2a5298" stroke-width="3"/>`;

            // Access devices
            const accessY = 280;
            const devices = [
                {x: 60, parent: 130},
                {x: 130, parent: 130},
                {x: 200, parent: 130},
                {x: 400, parent: 470},
                {x: 470, parent: 470},
                {x: 540, parent: 470}
            ];

            devices.forEach((d, i) => {
                svg += `<line x1="${d.parent}" y1="185" x2="${d.x}" y2="${accessY-25}" stroke="#2a5298" stroke-width="2"/>`;
                svg += `<circle cx="${d.x}" cy="${accessY}" r="22" fill="#3498db" stroke="#2980b9" stroke-width="2"/>`;
                svg += `<text x="${d.x}" y="${accessY+5}" text-anchor="middle" fill="white" font-size="10" font-weight="bold">PC${i+1}</text>`;
            });

            return svg;
        }

        function drawBus(cx, cy, count) {
            let svg = '';
            const busY = cy;
            const startX = 80;
            const endX = 520;

            // Bus backbone
            svg += `<line x1="${startX}" y1="${busY}" x2="${endX}" y2="${busY}" stroke="#e74c3c" stroke-width="6"/>`;

            // Terminators
            svg += `<rect x="${startX-15}" y="${busY-12}" width="18" height="24" fill="#c0392b" rx="3"/>`;
            svg += `<text x="${startX-6}" y="${busY+5}" text-anchor="middle" fill="white" font-size="10">T</text>`;
            svg += `<rect x="${endX-3}" y="${busY-12}" width="18" height="24" fill="#c0392b" rx="3"/>`;
            svg += `<text x="${endX+6}" y="${busY+5}" text-anchor="middle" fill="white" font-size="10">T</text>`;

            // Devices
            const spacing = (endX - startX - 40) / (count - 1);
            for (let i = 0; i < count; i++) {
                const x = startX + 20 + i * spacing;
                const y = busY - 90;

                svg += `<line x1="${x}" y1="${busY}" x2="${x}" y2="${y+25}" stroke="#2a5298" stroke-width="3"/>`;
                svg += `<circle cx="${x}" cy="${y}" r="25" fill="#3498db" stroke="#2980b9" stroke-width="2"/>`;
                svg += `<text x="${x}" y="${y+5}" text-anchor="middle" fill="white" font-size="12" font-weight="bold">PC${i+1}</text>`;
            }

            // Label
            svg += `<text x="${cx}" y="${busY+40}" text-anchor="middle" fill="#e74c3c" font-size="14" font-weight="bold">Backbone Cable (Coax)</text>`;

            return svg;
        }

        function drawRing(cx, cy, count) {
            let svg = '';
            const radius = 170;

            // Draw connections first (as ring)
            for (let i = 0; i < count; i++) {
                const angle1 = (i * 2 * Math.PI / count) - Math.PI/2;
                const angle2 = ((i + 1) % count * 2 * Math.PI / count) - Math.PI/2;
                const x1 = cx + radius * Math.cos(angle1);
                const y1 = cy + radius * Math.sin(angle1);
                const x2 = cx + radius * Math.cos(angle2);
                const y2 = cy + radius * Math.sin(angle2);

                svg += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="#2a5298" stroke-width="3"/>`;
            }

            // Draw direction arrow
            const arrowAngle = Math.PI / 4;
            const arrowX = cx + (radius - 50) * Math.cos(arrowAngle);
            const arrowY = cy + (radius - 50) * Math.sin(arrowAngle);
            svg += `<text x="${cx}" y="${cy}" text-anchor="middle" fill="#666" font-size="13">Token passes</text>`;
            svg += `<text x="${cx}" y="${cy+18}" text-anchor="middle" fill="#666" font-size="13">clockwise →</text>`;

            // Draw devices
            for (let i = 0; i < count; i++) {
                const angle = (i * 2 * Math.PI / count) - Math.PI/2;
                const x = cx + radius * Math.cos(angle);
                const y = cy + radius * Math.sin(angle);

                svg += `<circle cx="${x}" cy="${y}" r="25" fill="#3498db" stroke="#2980b9" stroke-width="2"/>`;
                svg += `<text x="${x}" y="${y+5}" text-anchor="middle" fill="white" font-size="12" font-weight="bold">PC${i+1}</text>`;
            }

            return svg;
        }

        function drawFullMesh(cx, cy, count) {
            let svg = '';
            const radius = 170;
            const positions = [];

            // Calculate positions
            for (let i = 0; i < count; i++) {
                const angle = (i * 2 * Math.PI / count) - Math.PI/2;
                positions.push({
                    x: cx + radius * Math.cos(angle),
                    y: cy + radius * Math.sin(angle)
                });
            }

            // Draw all connections
            for (let i = 0; i < count; i++) {
                for (let j = i + 1; j < count; j++) {
                    svg += `<line x1="${positions[i].x}" y1="${positions[i].y}" x2="${positions[j].x}" y2="${positions[j].y}" stroke="#2a5298" stroke-width="2" opacity="0.6"/>`;
                }
            }

            // Draw devices
            positions.forEach((pos, i) => {
                svg += `<circle cx="${pos.x}" cy="${pos.y}" r="25" fill="#3498db" stroke="#2980b9" stroke-width="2"/>`;
                svg += `<text x="${pos.x}" y="${pos.y+5}" text-anchor="middle" fill="white" font-size="12" font-weight="bold">R${i+1}</text>`;
            });

            // Connection count
            const conns = (count * (count - 1)) / 2;
            svg += `<text x="${cx}" y="${cy}" text-anchor="middle" fill="#666" font-size="14" font-weight="bold">${conns} connections</text>`;

            return svg;
        }

        function drawPartialMesh(cx, cy, count) {
            let svg = '';
            const radius = 170;
            const positions = [];

            // Calculate positions
            for (let i = 0; i < count; i++) {
                const angle = (i * 2 * Math.PI / count) - Math.PI/2;
                positions.push({
                    x: cx + radius * Math.cos(angle),
                    y: cy + radius * Math.sin(angle)
                });
            }

            // Draw some connections (not all)
            const connections = [
                [0, 1], [1, 2], [2, 3], [3, 4 % count], [4 % count, 0], // Ring
                [0, 2], [1, 3] // Extra cross connections
            ];

            connections.forEach(([i, j]) => {
                if (i < count && j < count) {
                    svg += `<line x1="${positions[i].x}" y1="${positions[i].y}" x2="${positions[j].x}" y2="${positions[j].y}" stroke="#2a5298" stroke-width="3"/>`;
                }
            });

            // Draw devices
            positions.forEach((pos, i) => {
                svg += `<circle cx="${pos.x}" cy="${pos.y}" r="25" fill="#3498db" stroke="#2980b9" stroke-width="2"/>`;
                svg += `<text x="${pos.x}" y="${pos.y+5}" text-anchor="middle" fill="white" font-size="12" font-weight="bold">R${i+1}</text>`;
            });

            svg += `<text x="${cx}" y="${cy}" text-anchor="middle" fill="#666" font-size="13">Partial Mesh:</text>`;
            svg += `<text x="${cx}" y="${cy+18}" text-anchor="middle" fill="#666" font-size="13">Strategic redundancy</text>`;

            return svg;
        }

        function drawHybrid(cx, cy) {
            let svg = '';

            // Core switches (mesh)
            svg += `<rect x="${cx-80}" y="40" width="50" height="35" rx="4" fill="#e74c3c" stroke="#c0392b" stroke-width="2"/>`;
            svg += `<text x="${cx-55}" y="62" text-anchor="middle" fill="white" font-size="10" font-weight="bold">Core1</text>`;
            svg += `<rect x="${cx+30}" y="40" width="50" height="35" rx="4" fill="#e74c3c" stroke="#c0392b" stroke-width="2"/>`;
            svg += `<text x="${cx+55}" y="62" text-anchor="middle" fill="white" font-size="10" font-weight="bold">Core2</text>`;

            // Core mesh link
            svg += `<line x1="${cx-30}" y1="57" x2="${cx+30}" y2="57" stroke="#c0392b" stroke-width="3"/>`;

            // Distribution switches
            svg += `<rect x="80" y="140" width="55" height="32" rx="4" fill="#9b59b6" stroke="#8e44ad" stroke-width="2"/>`;
            svg += `<text x="107" y="160" text-anchor="middle" fill="white" font-size="10" font-weight="bold">Dist1</text>`;
            svg += `<rect x="465" y="140" width="55" height="32" rx="4" fill="#9b59b6" stroke="#8e44ad" stroke-width="2"/>`;
            svg += `<text x="492" y="160" text-anchor="middle" fill="white" font-size="10" font-weight="bold">Dist2</text>`;

            // Distribution to Core (partial mesh - each dist to both cores)
            svg += `<line x1="107" y1="140" x2="${cx-55}" y2="75" stroke="#2a5298" stroke-width="2"/>`;
            svg += `<line x1="107" y1="140" x2="${cx+55}" y2="75" stroke="#2a5298" stroke-width="2"/>`;
            svg += `<line x1="492" y1="140" x2="${cx-55}" y2="75" stroke="#2a5298" stroke-width="2"/>`;
            svg += `<line x1="492" y1="140" x2="${cx+55}" y2="75" stroke="#2a5298" stroke-width="2"/>`;

            // Access switches (star to distribution)
            const accessY = 250;
            svg += `<rect x="50" y="${accessY}" width="45" height="28" rx="3" fill="#27ae60" stroke="#1e8449" stroke-width="2"/>`;
            svg += `<text x="72" y="${accessY+18}" text-anchor="middle" fill="white" font-size="9" font-weight="bold">Acc1</text>`;
            svg += `<rect x="140" y="${accessY}" width="45" height="28" rx="3" fill="#27ae60" stroke="#1e8449" stroke-width="2"/>`;
            svg += `<text x="162" y="${accessY+18}" text-anchor="middle" fill="white" font-size="9" font-weight="bold">Acc2</text>`;
            svg += `<rect x="415" y="${accessY}" width="45" height="28" rx="3" fill="#27ae60" stroke="#1e8449" stroke-width="2"/>`;
            svg += `<text x="437" y="${accessY+18}" text-anchor="middle" fill="white" font-size="9" font-weight="bold">Acc3</text>`;
            svg += `<rect x="505" y="${accessY}" width="45" height="28" rx="3" fill="#27ae60" stroke="#1e8449" stroke-width="2"/>`;
            svg += `<text x="527" y="${accessY+18}" text-anchor="middle" fill="white" font-size="9" font-weight="bold">Acc4</text>`;

            // Access to Distribution links
            svg += `<line x1="72" y1="${accessY}" x2="107" y2="172" stroke="#2a5298" stroke-width="2"/>`;
            svg += `<line x1="162" y1="${accessY}" x2="107" y2="172" stroke="#2a5298" stroke-width="2"/>`;
            svg += `<line x1="437" y1="${accessY}" x2="492" y2="172" stroke="#2a5298" stroke-width="2"/>`;
            svg += `<line x1="527" y1="${accessY}" x2="492" y2="172" stroke="#2a5298" stroke-width="2"/>`;

            // End devices (star to access)
            const endY = 340;
            const endDevices = [
                {x: 50, parent: 72}, {x: 95, parent: 72},
                {x: 140, parent: 162}, {x: 185, parent: 162},
                {x: 415, parent: 437}, {x: 460, parent: 437},
                {x: 505, parent: 527}, {x: 550, parent: 527}
            ];

            endDevices.forEach((d, i) => {
                svg += `<line x1="${d.parent}" y1="${accessY+28}" x2="${d.x}" y2="${endY-15}" stroke="#2a5298" stroke-width="2"/>`;
                svg += `<circle cx="${d.x}" cy="${endY}" r="15" fill="#3498db" stroke="#2980b9" stroke-width="2"/>`;
            });

            // Labels
            svg += `<text x="${cx}" y="25" text-anchor="middle" fill="#e74c3c" font-size="12" font-weight="bold">CORE (Mesh)</text>`;
            svg += `<text x="${cx}" y="130" text-anchor="middle" fill="#9b59b6" font-size="12" font-weight="bold">DISTRIBUTION (Partial Mesh)</text>`;
            svg += `<text x="${cx}" y="235" text-anchor="middle" fill="#27ae60" font-size="12" font-weight="bold">ACCESS (Star)</text>`;

            return svg;
        }

        function drawSpineLeaf(cx, cy) {
            let svg = '';

            // Spine switches
            const spines = [{x: cx-150}, {x: cx}, {x: cx+150}];
            spines.forEach((s, i) => {
                svg += `<rect x="${s.x-30}" y="50" width="60" height="35" rx="4" fill="#e74c3c" stroke="#c0392b" stroke-width="2"/>`;
                svg += `<text x="${s.x}" y="72" text-anchor="middle" fill="white" font-size="11" font-weight="bold">Spine${i+1}</text>`;
            });

            // Leaf switches
            const leaves = [{x: 80}, {x: 200}, {x: 320}, {x: 440}, {x: 520}];
            leaves.forEach((l, i) => {
                svg += `<rect x="${l.x-25}" y="180" width="50" height="30" rx="4" fill="#27ae60" stroke="#1e8449" stroke-width="2"/>`;
                svg += `<text x="${l.x}" y="200" text-anchor="middle" fill="white" font-size="10" font-weight="bold">Leaf${i+1}</text>`;
            });

            // Full mesh between spines and leaves
            leaves.forEach(leaf => {
                spines.forEach(spine => {
                    svg += `<line x1="${leaf.x}" y1="180" x2="${spine.x}" y2="85" stroke="#2a5298" stroke-width="2" opacity="0.6"/>`;
                });
            });

            // Servers under leaves
            const serverY = 290;
            leaves.forEach((l, i) => {
                svg += `<line x1="${l.x}" y1="210" x2="${l.x-15}" y2="${serverY-15}" stroke="#2a5298" stroke-width="2"/>`;
                svg += `<line x1="${l.x}" y1="210" x2="${l.x+15}" y2="${serverY-15}" stroke="#2a5298" stroke-width="2"/>`;
                svg += `<rect x="${l.x-30}" y="${serverY}" width="25" height="20" rx="2" fill="#3498db" stroke="#2980b9" stroke-width="1"/>`;
                svg += `<rect x="${l.x+5}" y="${serverY}" width="25" height="20" rx="2" fill="#3498db" stroke="#2980b9" stroke-width="1"/>`;
            });

            // Labels
            svg += `<text x="${cx}" y="35" text-anchor="middle" fill="#e74c3c" font-size="14" font-weight="bold">SPINE LAYER</text>`;
            svg += `<text x="${cx}" y="160" text-anchor="middle" fill="#27ae60" font-size="14" font-weight="bold">LEAF LAYER</text>`;
            svg += `<text x="${cx}" y="340" text-anchor="middle" fill="#3498db" font-size="12">Servers (max 2 hops between any two)</text>`;

            return svg;
        }

        // ===============================
        // COMPARISON TAB
        // ===============================
        function toggleCompare(element, topology) {
            element.classList.toggle('selected');

            // Update table highlighting
            const colIndex = {
                'star': 1, 'bus': 2, 'ring': 3,
                'full-mesh': 4, 'partial-mesh': 5, 'hybrid': 6
            }[topology];

            const table = document.querySelector('.comparison-table');
            const rows = table.querySelectorAll('tbody tr');

            rows.forEach(row => {
                const cell = row.children[colIndex];
                if (cell) {
                    cell.classList.toggle('highlight');
                }
            });
        }

        // ===============================
        // MESH CALCULATOR
        // ===============================
        function calculateMesh() {
            const n = parseInt(document.getElementById('mesh-devices').value) || 2;
            const connections = (n * (n - 1)) / 2;

            document.getElementById('mesh-result').textContent = connections;
            document.getElementById('mesh-explanation').textContent =
                `${n} devices, each connected to ${n-1} others = ${n*(n-1)} links, but since each link is shared by 2 devices, we divide by 2.`;
        }

        function setDevices(n) {
            document.getElementById('mesh-devices').value = n;
            calculateMesh();
        }

        // ===============================
        // ANIMATION TAB
        // ===============================
        let animationInterval = null;

        function initAnimation() {
            resetAnimation();
            const topology = document.getElementById('anim-topology').value;
            drawAnimationTopology(topology);
        }

        function drawAnimationTopology(topology) {
            const svg = document.getElementById('animation-svg');
            const cx = 300, cy = 225;
            let content = '';

            switch(topology) {
                case 'star':
                    content = drawAnimStar(cx, cy);
                    break;
                case 'bus':
                    content = drawAnimBus(cx, cy);
                    break;
                case 'ring':
                    content = drawAnimRing(cx, cy);
                    break;
                case 'mesh':
                    content = drawAnimMesh(cx, cy);
                    break;
            }

            svg.innerHTML = content;
        }

        function drawAnimStar(cx, cy) {
            let svg = '';
            // Switch
            svg += `<rect id="anim-switch" x="${cx-25}" y="${cy-15}" width="50" height="30" rx="4" fill="#e74c3c"/>`;
            svg += `<text x="${cx}" y="${cy+5}" text-anchor="middle" fill="white" font-size="12">Switch</text>`;

            // PCs
            const positions = [
                {x: cx, y: cy-120, id: 'PC1'},
                {x: cx+130, y: cy-40, id: 'PC2'},
                {x: cx+100, y: cy+100, id: 'PC3'},
                {x: cx-100, y: cy+100, id: 'PC4'},
                {x: cx-130, y: cy-40, id: 'PC5'}
            ];

            positions.forEach(p => {
                svg += `<line class="anim-link" data-from="${p.id}" data-to="Switch" x1="${cx}" y1="${cy}" x2="${p.x}" y2="${p.y}" stroke="#2a5298" stroke-width="3"/>`;
                svg += `<circle id="anim-${p.id}" cx="${p.x}" cy="${p.y}" r="30" fill="#3498db"/>`;
                svg += `<text x="${p.x}" y="${p.y+5}" text-anchor="middle" fill="white" font-size="12" font-weight="bold">${p.id}</text>`;
            });

            return svg;
        }

        function drawAnimBus(cx, cy) {
            let svg = '';
            const busY = cy;

            svg += `<line id="anim-bus" x1="50" y1="${busY}" x2="550" y2="${busY}" stroke="#e74c3c" stroke-width="5"/>`;

            const positions = [{x: 120}, {x: 220}, {x: 320}, {x: 420}];
            positions.forEach((p, i) => {
                svg += `<line class="anim-link" x1="${p.x}" y1="${busY}" x2="${p.x}" y2="${busY-70}" stroke="#2a5298" stroke-width="3"/>`;
                svg += `<circle id="anim-PC${i+1}" cx="${p.x}" cy="${busY-100}" r="30" fill="#3498db"/>`;
                svg += `<text x="${p.x}" y="${busY-95}" text-anchor="middle" fill="white" font-size="12" font-weight="bold">PC${i+1}</text>`;
            });

            return svg;
        }

        function drawAnimRing(cx, cy) {
            let svg = '';
            const radius = 140;
            const count = 5;

            for (let i = 0; i < count; i++) {
                const angle1 = (i * 2 * Math.PI / count) - Math.PI/2;
                const angle2 = ((i + 1) % count * 2 * Math.PI / count) - Math.PI/2;
                const x1 = cx + radius * Math.cos(angle1);
                const y1 = cy + radius * Math.sin(angle1);
                const x2 = cx + radius * Math.cos(angle2);
                const y2 = cy + radius * Math.sin(angle2);

                svg += `<line class="anim-link" x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="#2a5298" stroke-width="3"/>`;
            }

            for (let i = 0; i < count; i++) {
                const angle = (i * 2 * Math.PI / count) - Math.PI/2;
                const x = cx + radius * Math.cos(angle);
                const y = cy + radius * Math.sin(angle);

                svg += `<circle id="anim-PC${i+1}" cx="${x}" cy="${y}" r="30" fill="#3498db"/>`;
                svg += `<text x="${x}" y="${y+5}" text-anchor="middle" fill="white" font-size="12" font-weight="bold">PC${i+1}</text>`;
            }

            return svg;
        }

        function drawAnimMesh(cx, cy) {
            let svg = '';
            const radius = 140;
            const count = 4;
            const positions = [];

            for (let i = 0; i < count; i++) {
                const angle = (i * 2 * Math.PI / count) - Math.PI/2;
                positions.push({
                    x: cx + radius * Math.cos(angle),
                    y: cy + radius * Math.sin(angle)
                });
            }

            // All connections
            for (let i = 0; i < count; i++) {
                for (let j = i + 1; j < count; j++) {
                    svg += `<line class="anim-link" x1="${positions[i].x}" y1="${positions[i].y}" x2="${positions[j].x}" y2="${positions[j].y}" stroke="#2a5298" stroke-width="3"/>`;
                }
            }

            positions.forEach((p, i) => {
                svg += `<circle id="anim-R${i+1}" cx="${p.x}" cy="${p.y}" r="30" fill="#3498db"/>`;
                svg += `<text x="${p.x}" y="${p.y+5}" text-anchor="middle" fill="white" font-size="12" font-weight="bold">R${i+1}</text>`;
            });

            return svg;
        }

        function startAnimation() {
            resetAnimation();
            const topology = document.getElementById('anim-topology').value;
            const scenario = document.getElementById('anim-scenario').value;

            // Simple animation - move a packet
            const canvas = document.querySelector('.animation-canvas');
            const packet = document.createElement('div');
            packet.className = 'packet';
            packet.id = 'anim-packet';
            canvas.appendChild(packet);

            // Get path based on topology and scenario
            const path = getAnimationPath(topology, scenario);
            animatePacket(packet, path, 0);

            // Update status
            document.getElementById('status-source').textContent = path[0].name;
            document.getElementById('status-dest').textContent = path[path.length-1].name;
            document.getElementById('status-hops').textContent = path.length - 1;
            document.getElementById('status-path').textContent = path.map(p => p.name).join(' → ');
        }

        function getAnimationPath(topology, scenario) {
            const svg = document.getElementById('animation-svg');
            const rect = svg.getBoundingClientRect();
            const scale = rect.width / 600;
            const cx = 300, cy = 225;
            const radius = 140;

            // Calculate ring positions for ring topology
            const ringPositions = [];
            for (let i = 0; i < 5; i++) {
                const angle = (i * 2 * Math.PI / 5) - Math.PI/2;
                ringPositions.push({
                    x: cx + radius * Math.cos(angle),
                    y: cy + radius * Math.sin(angle),
                    name: `PC${i+1}`
                });
            }

            // Calculate mesh positions for mesh topology
            const meshPositions = [];
            for (let i = 0; i < 4; i++) {
                const angle = (i * 2 * Math.PI / 4) - Math.PI/2;
                meshPositions.push({
                    x: cx + radius * Math.cos(angle),
                    y: cy + radius * Math.sin(angle),
                    name: `R${i+1}`
                });
            }

            // Star topology positions
            const starPositions = {
                'Switch': {x: cx, y: cy, name: 'Switch'},
                'PC1': {x: cx, y: cy-120, name: 'PC1'},
                'PC2': {x: cx+130, y: cy-40, name: 'PC2'},
                'PC3': {x: cx+100, y: cy+100, name: 'PC3'},
                'PC4': {x: cx-100, y: cy+100, name: 'PC4'},
                'PC5': {x: cx-130, y: cy-40, name: 'PC5'}
            };

            // Bus topology positions
            const busPositions = {
                'PC1': {x: 120, y: 125, name: 'PC1'},
                'PC2': {x: 220, y: 125, name: 'PC2'},
                'PC3': {x: 320, y: 125, name: 'PC3'},
                'PC4': {x: 420, y: 125, name: 'PC4'},
                'Bus1': {x: 120, y: 225, name: 'Bus'},
                'Bus2': {x: 220, y: 225, name: 'Bus'},
                'Bus3': {x: 320, y: 225, name: 'Bus'},
                'Bus4': {x: 420, y: 225, name: 'Bus'}
            };

            let path = [];

            switch(topology) {
                case 'star':
                    if (scenario === 'unicast') {
                        // PC1 -> Switch -> PC3
                        path = [
                            starPositions['PC1'],
                            starPositions['Switch'],
                            starPositions['PC3']
                        ];
                    } else if (scenario === 'broadcast') {
                        // PC1 -> Switch -> All PCs (simulated as visiting each)
                        path = [
                            starPositions['PC1'],
                            starPositions['Switch'],
                            starPositions['PC2'],
                            starPositions['Switch'],
                            starPositions['PC3'],
                            starPositions['Switch'],
                            starPositions['PC4'],
                            starPositions['Switch'],
                            starPositions['PC5']
                        ];
                    } else if (scenario === 'failure') {
                        // PC1 -> Switch (failure) -> attempt PC3 -> reroute via PC5
                        path = [
                            starPositions['PC1'],
                            starPositions['Switch'],
                            {x: (starPositions['Switch'].x + starPositions['PC3'].x)/2,
                             y: (starPositions['Switch'].y + starPositions['PC3'].y)/2,
                             name: '❌ Link Down!'},
                            starPositions['Switch'],
                            starPositions['PC5'],
                            starPositions['Switch'],
                            starPositions['PC4']
                        ];
                    }
                    break;

                case 'bus':
                    if (scenario === 'unicast') {
                        // PC1 -> Bus -> PC3
                        path = [
                            busPositions['PC1'],
                            busPositions['Bus1'],
                            busPositions['Bus3'],
                            busPositions['PC3']
                        ];
                    } else if (scenario === 'broadcast') {
                        // Signal travels entire bus
                        path = [
                            busPositions['PC1'],
                            busPositions['Bus1'],
                            busPositions['Bus2'],
                            busPositions['PC2'],
                            busPositions['Bus2'],
                            busPositions['Bus3'],
                            busPositions['PC3'],
                            busPositions['Bus3'],
                            busPositions['Bus4'],
                            busPositions['PC4']
                        ];
                    } else if (scenario === 'failure') {
                        // Bus break - network segments isolated
                        path = [
                            busPositions['PC1'],
                            busPositions['Bus1'],
                            busPositions['Bus2'],
                            {x: 270, y: 225, name: '❌ Cable Break!'},
                            busPositions['Bus2'],
                            busPositions['PC2'],
                            busPositions['Bus2'],
                            {x: 270, y: 225, name: '❌ Cannot Reach PC3/PC4!'}
                        ];
                    }
                    break;

                case 'ring':
                    if (scenario === 'unicast') {
                        // PC1 -> PC2 -> PC3 (clockwise)
                        path = [
                            ringPositions[0],
                            ringPositions[1],
                            ringPositions[2]
                        ];
                    } else if (scenario === 'broadcast') {
                        // Token circles entire ring
                        path = [
                            ringPositions[0],
                            ringPositions[1],
                            ringPositions[2],
                            ringPositions[3],
                            ringPositions[4],
                            ringPositions[0]
                        ];
                    } else if (scenario === 'failure') {
                        // Link fails, go counterclockwise instead
                        path = [
                            ringPositions[0],
                            {x: (ringPositions[0].x + ringPositions[1].x)/2,
                             y: (ringPositions[0].y + ringPositions[1].y)/2,
                             name: '❌ Link Failed!'},
                            ringPositions[0],
                            ringPositions[4],
                            ringPositions[3],
                            ringPositions[2]
                        ];
                    }
                    break;

                case 'mesh':
                    if (scenario === 'unicast') {
                        // R1 direct to R4 (shortest path)
                        path = [
                            meshPositions[0],
                            meshPositions[3]
                        ];
                    } else if (scenario === 'broadcast') {
                        // Visit all routers
                        path = [
                            meshPositions[0],
                            meshPositions[1],
                            meshPositions[2],
                            meshPositions[3],
                            meshPositions[0]
                        ];
                    } else if (scenario === 'failure') {
                        // Direct link fails, reroute through other routers
                        path = [
                            meshPositions[0],
                            {x: (meshPositions[0].x + meshPositions[3].x)/2,
                             y: (meshPositions[0].y + meshPositions[3].y)/2,
                             name: '❌ Link Down!'},
                            meshPositions[0],
                            meshPositions[1],
                            meshPositions[2],
                            meshPositions[3]
                        ];
                    }
                    break;
            }

            // Apply scale to all positions
            return path.map(p => ({
                x: p.x * scale,
                y: p.y * scale,
                name: p.name
            }));
        }

        function animatePacket(packet, path, index) {
            if (index >= path.length) {
                setTimeout(() => {
                    packet.remove();
                }, 500);
                return;
            }

            packet.style.left = path[index].x + 'px';
            packet.style.top = path[index].y + 'px';
            packet.style.transition = index === 0 ? 'none' : 'all 0.8s ease-in-out';

            setTimeout(() => {
                animatePacket(packet, path, index + 1);
            }, 1000);
        }

        function resetAnimation() {
            const packet = document.getElementById('anim-packet');
            if (packet) packet.remove();
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
        }

        // ===============================
        // QUIZ TAB
        // ===============================
        const quizQuestions = [
            {
                question: "What is the main disadvantage of star topology?",
                options: [
                    "Too expensive",
                    "Central device is a single point of failure",
                    "Cannot add new devices",
                    "Requires terminators"
                ],
                correct: 1,
                explanation: "In star topology, if the central switch or hub fails, all connected devices lose network access."
            },
            {
                question: "How many connections are needed for a full mesh network with 6 devices?",
                options: ["6", "12", "15", "30"],
                correct: 2,
                explanation: "Using the formula n(n-1)/2: 6(5)/2 = 15 connections."
            },
            {
                question: "Which topology uses token passing to prevent collisions?",
                options: ["Star", "Bus", "Ring", "Mesh"],
                correct: 2,
                explanation: "Ring topology uses token passing where only the device with the token can transmit."
            },
            {
                question: "A network is physically wired as a star but uses Ethernet with a hub. What is the logical topology?",
                options: ["Star", "Bus", "Ring", "Mesh"],
                correct: 1,
                explanation: "With a hub, Ethernet behaves as a logical bus because all traffic is broadcast to all ports."
            },
            {
                question: "Which layer in three-tier architecture handles ACLs and QoS policies?",
                options: ["Core", "Distribution", "Access", "Physical"],
                correct: 1,
                explanation: "The Distribution layer is responsible for policy enforcement including ACLs, QoS, and routing between VLANs."
            },
            {
                question: "What is the primary advantage of spine-leaf architecture?",
                options: [
                    "Lower cost",
                    "Simpler design",
                    "Predictable latency with max 2 hops",
                    "Uses less cabling"
                ],
                correct: 2,
                explanation: "In spine-leaf, every leaf connects to every spine, ensuring any server can reach any other in exactly 2 hops."
            },
            {
                question: "Bus topology requires what component at both ends of the backbone?",
                options: ["Switches", "Routers", "Terminators", "Repeaters"],
                correct: 2,
                explanation: "Terminators absorb the signal at both ends of a bus to prevent signal reflection."
            },
            {
                question: "Which WAN technology has SD-WAN largely started to replace for cost savings?",
                options: ["Ethernet", "Token Ring", "MPLS", "FDDI"],
                correct: 2,
                explanation: "SD-WAN can use cheaper Internet connections instead of expensive MPLS while maintaining reliability through intelligent path selection."
            },
            {
                question: "What type of network spans a city or metropolitan area?",
                options: ["LAN", "WAN", "MAN", "PAN"],
                correct: 2,
                explanation: "MAN (Metropolitan Area Network) covers a city or metro area, larger than LAN but smaller than WAN."
            },
            {
                question: "In which scenario would you use full mesh topology?",
                options: [
                    "Connecting 100 PCs in an office",
                    "Connecting 3 critical data centers",
                    "A home network",
                    "Connecting all students in a classroom"
                ],
                correct: 1,
                explanation: "Full mesh is ideal for small numbers of critical devices (like data centers) where maximum redundancy is essential, but doesn't scale for many devices."
            }
        ];

        let quizStarted = false;
        let currentQuestion = 0;
        let score = 0;
        let answered = false;

        function startQuiz() {
            quizStarted = true;
            currentQuestion = 0;
            score = 0;
            document.getElementById('quiz-results').style.display = 'none';
            showQuestion();
        }

        function showQuestion() {
            answered = false;
            const q = quizQuestions[currentQuestion];

            document.getElementById('quiz-current').textContent = `Question ${currentQuestion + 1} of ${quizQuestions.length}`;
            document.getElementById('quiz-progress-bar').style.width = `${((currentQuestion + 1) / quizQuestions.length) * 100}%`;
            document.getElementById('quiz-score-display').textContent = `Score: ${score}/${currentQuestion}`;

            let html = `
                <div class="quiz-question-container">
                    <div class="quiz-question">${q.question}</div>
                    <div class="quiz-options">
                        ${q.options.map((opt, i) => `
                            <div class="quiz-option" onclick="selectAnswer(${i})" data-index="${i}">
                                ${opt}
                            </div>
                        `).join('')}
                    </div>
                    <div class="quiz-feedback" id="quiz-feedback"></div>
                    <div style="margin-top: 20px; text-align: center;">
                        <button class="quiz-btn" id="next-btn" onclick="nextQuestion()" disabled>
                            ${currentQuestion < quizQuestions.length - 1 ? 'Next Question' : 'See Results'}
                        </button>
                    </div>
                </div>
            `;

            document.getElementById('quiz-question-area').innerHTML = html;
        }

        function selectAnswer(index) {
            if (answered) return;
            answered = true;

            const q = quizQuestions[currentQuestion];
            const options = document.querySelectorAll('.quiz-option');

            options.forEach((opt, i) => {
                opt.classList.add('disabled');
                if (i === q.correct) {
                    opt.classList.add('correct');
                } else if (i === index && i !== q.correct) {
                    opt.classList.add('incorrect');
                }
            });

            const feedback = document.getElementById('quiz-feedback');
            if (index === q.correct) {
                score++;
                feedback.className = 'quiz-feedback show correct';
                feedback.innerHTML = `<strong>Correct!</strong> ${q.explanation}`;
            } else {
                feedback.className = 'quiz-feedback show incorrect';
                feedback.innerHTML = `<strong>Incorrect.</strong> ${q.explanation}`;
            }

            document.getElementById('next-btn').disabled = false;
        }

        function nextQuestion() {
            currentQuestion++;
            if (currentQuestion < quizQuestions.length) {
                showQuestion();
            } else {
                showResults();
            }
        }

        function showResults() {
            document.getElementById('quiz-question-area').innerHTML = '';
            document.getElementById('quiz-results').style.display = 'block';

            const percentage = (score / quizQuestions.length) * 100;
            const scoreEl = document.getElementById('final-score');
            scoreEl.textContent = `${score}/${quizQuestions.length}`;

            if (percentage >= 80) {
                scoreEl.className = 'quiz-score excellent';
                document.getElementById('score-message').textContent = 'Excellent! You have a strong understanding of network topologies!';
            } else if (percentage >= 60) {
                scoreEl.className = 'quiz-score good';
                document.getElementById('score-message').textContent = 'Good job! Review the topics you missed and try again.';
            } else {
                scoreEl.className = 'quiz-score needs-work';
                document.getElementById('score-message').textContent = 'Keep studying! Review the presentation and try the visualizer to strengthen your understanding.';
            }
        }

        function restartQuiz() {
            startQuiz();
        }

        // ===============================
        // INITIALIZATION
        // ===============================
        document.addEventListener('DOMContentLoaded', function() {
            loadTopology('star');
            calculateMesh();
        });
    </script>
</body>
</html>
