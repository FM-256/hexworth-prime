<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Malware Analysis Toolkit - Dark Arts Vault</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0d0a1a 0%, #1a0e2e 100%);
            color: #b8a5c8;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            border-bottom: 2px solid #9a7aaa;
            position: relative;
        }

        h1 {
            color: #d4b5e5;
            font-size: 2.5em;
            text-shadow: 0 0 20px rgba(154, 122, 170, 0.5);
            margin-bottom: 10px;
            letter-spacing: 2px;
        }

        .subtitle {
            color: #9a7aaa;
            font-size: 1.1em;
            font-style: italic;
        }

        .tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 30px;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #9a7aaa;
        }

        .tab-button {
            background: linear-gradient(135deg, #2a1a3a 0%, #1a0e2e 100%);
            color: #b8a5c8;
            border: 2px solid #9a7aaa;
            padding: 12px 20px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            border-radius: 5px;
            transition: all 0.3s ease;
            flex: 1;
            min-width: 150px;
        }

        .tab-button:hover {
            background: linear-gradient(135deg, #3a2a4a 0%, #2a1e3e 100%);
            box-shadow: 0 0 15px rgba(154, 122, 170, 0.4);
            transform: translateY(-2px);
        }

        .tab-button.active {
            background: linear-gradient(135deg, #9a7aaa 0%, #7a5a8a 100%);
            color: #0d0a1a;
            font-weight: bold;
            box-shadow: 0 0 20px rgba(154, 122, 170, 0.6);
        }

        .tool-panel {
            display: none;
            background: rgba(0, 0, 0, 0.4);
            padding: 30px;
            border-radius: 10px;
            border: 2px solid #9a7aaa;
            box-shadow: 0 0 30px rgba(154, 122, 170, 0.2);
            animation: fadeIn 0.4s ease;
        }

        .tool-panel.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .tool-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #9a7aaa;
        }

        .tool-title {
            color: #d4b5e5;
            font-size: 1.8em;
            text-shadow: 0 0 10px rgba(154, 122, 170, 0.3);
        }

        .info-button {
            background: rgba(154, 122, 170, 0.2);
            border: 1px solid #9a7aaa;
            color: #d4b5e5;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.3s ease;
        }

        .info-button:hover {
            background: rgba(154, 122, 170, 0.4);
            box-shadow: 0 0 10px rgba(154, 122, 170, 0.3);
        }

        .info-panel {
            display: none;
            background: rgba(154, 122, 170, 0.1);
            border: 1px solid #9a7aaa;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 0.95em;
            line-height: 1.6;
        }

        .info-panel.visible {
            display: block;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                max-height: 0;
            }
            to {
                opacity: 1;
                max-height: 500px;
            }
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            color: #d4b5e5;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        input[type="text"],
        textarea,
        select {
            width: 100%;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #9a7aaa;
            color: #b8a5c8;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        input[type="text"]:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: #d4b5e5;
            box-shadow: 0 0 10px rgba(154, 122, 170, 0.3);
        }

        textarea {
            resize: vertical;
            min-height: 120px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        button {
            background: linear-gradient(135deg, #9a7aaa 0%, #7a5a8a 100%);
            color: #0d0a1a;
            border: none;
            padding: 12px 24px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            border-radius: 5px;
            transition: all 0.3s ease;
            font-size: 1em;
        }

        button:hover {
            background: linear-gradient(135deg, #b897c8 0%, #9a7aaa 100%);
            box-shadow: 0 0 15px rgba(154, 122, 170, 0.5);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        .secondary-button {
            background: linear-gradient(135deg, #2a1a3a 0%, #1a0e2e 100%);
            color: #b8a5c8;
            border: 1px solid #9a7aaa;
        }

        .secondary-button:hover {
            background: linear-gradient(135deg, #3a2a4a 0%, #2a1e3e 100%);
        }

        .output-section {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #9a7aaa;
            border-radius: 5px;
            padding: 20px;
            margin-top: 20px;
            position: relative;
        }

        .output-header {
            color: #d4b5e5;
            font-size: 1.2em;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .copy-button {
            background: rgba(154, 122, 170, 0.3);
            padding: 6px 12px;
            font-size: 0.85em;
            border: 1px solid #9a7aaa;
            color: #d4b5e5;
        }

        .copy-button:hover {
            background: rgba(154, 122, 170, 0.5);
        }

        .output-content {
            color: #b8a5c8;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            word-break: break-all;
            line-height: 1.6;
        }

        .byte-display {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .byte {
            background: rgba(154, 122, 170, 0.2);
            border: 1px solid #9a7aaa;
            padding: 8px 10px;
            border-radius: 4px;
            font-size: 0.9em;
            min-width: 70px;
            text-align: center;
        }

        .byte.printable {
            background: rgba(122, 170, 154, 0.2);
            border-color: #7aaa9a;
        }

        .byte.non-printable {
            background: rgba(170, 122, 122, 0.2);
            border-color: #aa7a7a;
        }

        .entropy-bar {
            width: 100%;
            height: 40px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #9a7aaa;
            border-radius: 5px;
            position: relative;
            overflow: hidden;
            margin-top: 10px;
        }

        .entropy-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a7a4a 0%, #aa7a4a 50%, #aa4a4a 100%);
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .highlight-ip {
            background: rgba(255, 100, 100, 0.3);
            padding: 2px 4px;
            border-radius: 3px;
        }

        .highlight-url {
            background: rgba(255, 150, 100, 0.3);
            padding: 2px 4px;
            border-radius: 3px;
        }

        .highlight-path {
            background: rgba(150, 150, 255, 0.3);
            padding: 2px 4px;
            border-radius: 3px;
        }

        .highlight-registry {
            background: rgba(255, 255, 100, 0.3);
            padding: 2px 4px;
            border-radius: 3px;
        }

        .hash-result {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(154, 122, 170, 0.1);
            padding: 12px;
            border-radius: 5px;
            margin-bottom: 10px;
            border: 1px solid #9a7aaa;
        }

        .hash-label {
            color: #d4b5e5;
            font-weight: bold;
            min-width: 80px;
        }

        .hash-value {
            flex: 1;
            margin: 0 15px;
            word-break: break-all;
            color: #b8a5c8;
        }

        .xor-result-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .xor-result-item {
            background: rgba(154, 122, 170, 0.1);
            border: 1px solid #9a7aaa;
            padding: 12px;
            border-radius: 5px;
        }

        .xor-key {
            color: #d4b5e5;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .xor-score {
            color: #9a7aaa;
            font-size: 0.9em;
            margin-bottom: 8px;
        }

        .xor-preview {
            color: #b8a5c8;
            word-break: break-all;
            max-height: 60px;
            overflow: hidden;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 30px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #9a7aaa;
        }

        .tip {
            background: rgba(154, 122, 170, 0.15);
            border-left: 3px solid #9a7aaa;
            padding: 10px 15px;
            margin-top: 15px;
            border-radius: 3px;
            font-size: 0.9em;
            line-height: 1.5;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
            cursor: pointer;
        }

        .checkbox-group label {
            margin-bottom: 0;
            cursor: pointer;
        }

        .ioc-list {
            margin-top: 10px;
        }

        .ioc-category {
            margin-bottom: 15px;
        }

        .ioc-category-title {
            color: #d4b5e5;
            font-weight: bold;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px solid #9a7aaa;
        }

        .ioc-item {
            background: rgba(154, 122, 170, 0.1);
            padding: 8px 12px;
            margin-bottom: 5px;
            border-radius: 3px;
            border-left: 3px solid #9a7aaa;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
            }

            .tabs {
                flex-direction: column;
            }

            .tab-button {
                min-width: 100%;
            }

            .tool-panel {
                padding: 15px;
            }

            .xor-result-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>MALWARE ANALYSIS TOOLKIT</h1>
            <div class="subtitle">Dark Arts Vault - Advanced Binary Analysis Suite</div>
        </header>

        <div class="tabs">
            <button class="tab-button active" data-tab="hex-decoder">Hex Decoder</button>
            <button class="tab-button" data-tab="base64">Base64</button>
            <button class="tab-button" data-tab="string-analyzer">String Analyzer</button>
            <button class="tab-button" data-tab="hash-calculator">Hash Calculator</button>
            <button class="tab-button" data-tab="xor-decoder">XOR Decoder</button>
            <button class="tab-button" data-tab="entropy">Entropy Calculator</button>
            <button class="tab-button" data-tab="ioc-extractor">IOC Extractor</button>
        </div>

        <!-- Hex Decoder Tool -->
        <div class="tool-panel active" id="hex-decoder">
            <div class="tool-header">
                <h2 class="tool-title">Hex Decoder</h2>
                <button class="info-button" onclick="toggleInfo('hex-info')">Info</button>
            </div>

            <div class="info-panel" id="hex-info">
                <strong>Purpose:</strong> Convert hexadecimal data to ASCII text. Essential for analyzing hex dumps from memory, network captures, or binary files. Malware often hides strings in hex format to evade detection.
                <br><br>
                <strong>Usage:</strong> Paste hex values (with or without spaces, 0x prefix). Printable characters are highlighted in green, non-printable in red.
            </div>

            <div class="input-group">
                <label>Hex Input:</label>
                <textarea id="hex-input" placeholder="48656C6C6F20576F726C6421 or 48 65 6C 6C 6F"></textarea>
            </div>

            <div class="output-section">
                <div class="output-header">
                    <span>ASCII Output</span>
                    <button class="copy-button" onclick="copyToClipboard('hex-ascii-output')">Copy</button>
                </div>
                <div class="output-content" id="hex-ascii-output">Enter hex data to decode...</div>
            </div>

            <div class="output-section">
                <div class="output-header">
                    <span>Byte-by-Byte Breakdown</span>
                </div>
                <div class="byte-display" id="hex-byte-display"></div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(122, 170, 154, 0.2); border-color: #7aaa9a;"></div>
                    <span>Printable ASCII (32-126)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(170, 122, 122, 0.2); border-color: #aa7a7a;"></div>
                    <span>Non-Printable</span>
                </div>
            </div>
        </div>

        <!-- Base64 Tool -->
        <div class="tool-panel" id="base64">
            <div class="tool-header">
                <h2 class="tool-title">Base64 Encoder/Decoder</h2>
                <button class="info-button" onclick="toggleInfo('base64-info')">Info</button>
            </div>

            <div class="info-panel" id="base64-info">
                <strong>Purpose:</strong> Base64 encoding is commonly used in malware to obfuscate payloads, commands, and configuration data. It's also used in web attacks, email attachments, and data exfiltration.
                <br><br>
                <strong>Padding:</strong> Base64 uses '=' for padding when the input length isn't divisible by 3. URL-safe variant replaces '+' with '-' and '/' with '_'.
            </div>

            <div class="input-group">
                <label>Input:</label>
                <textarea id="base64-input" placeholder="Enter text or Base64 encoded data"></textarea>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="base64-urlsafe">
                <label for="base64-urlsafe">URL-Safe Encoding</label>
            </div>

            <div class="button-group">
                <button onclick="base64Encode()">Encode</button>
                <button onclick="base64Decode()">Decode</button>
            </div>

            <div class="output-section">
                <div class="output-header">
                    <span>Output</span>
                    <button class="copy-button" onclick="copyToClipboard('base64-output')">Copy</button>
                </div>
                <div class="output-content" id="base64-output">Results will appear here...</div>
            </div>

            <div class="tip">
                <strong>Tip:</strong> Base64 strings often end with '=' or '=='. Look for patterns like "TVq" (MZ header) or "JVB" (PDF header) which indicate encoded files.
            </div>
        </div>

        <!-- String Analyzer Tool -->
        <div class="tool-panel" id="string-analyzer">
            <div class="tool-header">
                <h2 class="tool-title">String Analyzer</h2>
                <button class="info-button" onclick="toggleInfo('string-info')">Info</button>
            </div>

            <div class="info-panel" id="string-info">
                <strong>Purpose:</strong> Extract printable ASCII strings from binary data. Critical for finding URLs, IPs, file paths, and commands embedded in malware samples.
                <br><br>
                <strong>Pattern Detection:</strong> Automatically highlights suspicious patterns like C2 servers, registry keys, and file paths commonly used by malware.
            </div>

            <div class="input-group">
                <label>Minimum String Length:</label>
                <input type="number" id="string-min-length" value="4" min="1" max="50">
            </div>

            <div class="input-group">
                <label>Binary Content (any text/data):</label>
                <textarea id="string-input" placeholder="Paste binary content, hex dump, or any data..."></textarea>
            </div>

            <button onclick="analyzeStrings()">Extract Strings</button>

            <div class="output-section">
                <div class="output-header">
                    <span>Extracted Strings (<span id="string-count">0</span> found)</span>
                    <button class="copy-button" onclick="copyToClipboard('string-output')">Copy</button>
                </div>
                <div class="output-content" id="string-output">Enter data to analyze...</div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color highlight-ip"></div>
                    <span>IP Addresses</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color highlight-url"></div>
                    <span>URLs/Domains</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color highlight-path"></div>
                    <span>File Paths</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color highlight-registry"></div>
                    <span>Registry Keys</span>
                </div>
            </div>
        </div>

        <!-- Hash Calculator Tool -->
        <div class="tool-panel" id="hash-calculator">
            <div class="tool-header">
                <h2 class="tool-title">Hash Calculator</h2>
                <button class="info-button" onclick="toggleInfo('hash-info')">Info</button>
            </div>

            <div class="info-panel" id="hash-info">
                <strong>Purpose:</strong> Calculate cryptographic hashes for malware identification and IOC tracking. Hashes are unique fingerprints used to identify known malicious files.
                <br><br>
                <strong>Hash Types:</strong>
                <ul style="margin-top: 10px;">
                    <li><strong>MD5:</strong> Fast but deprecated for security. Still used in malware databases.</li>
                    <li><strong>SHA-1:</strong> More secure than MD5. Common in older threat intelligence.</li>
                    <li><strong>SHA-256:</strong> Current standard for file identification and integrity.</li>
                </ul>
            </div>

            <div class="input-group">
                <label>Input Text:</label>
                <textarea id="hash-input" placeholder="Enter text to hash..."></textarea>
            </div>

            <div class="output-section">
                <div class="hash-result">
                    <span class="hash-label">MD5:</span>
                    <span class="hash-value" id="hash-md5">-</span>
                    <button class="copy-button" onclick="copyText(document.getElementById('hash-md5').textContent)">Copy</button>
                </div>
                <div class="hash-result">
                    <span class="hash-label">SHA-1:</span>
                    <span class="hash-value" id="hash-sha1">-</span>
                    <button class="copy-button" onclick="copyText(document.getElementById('hash-sha1').textContent)">Copy</button>
                </div>
                <div class="hash-result">
                    <span class="hash-label">SHA-256:</span>
                    <span class="hash-value" id="hash-sha256">-</span>
                    <button class="copy-button" onclick="copyText(document.getElementById('hash-sha256').textContent)">Copy</button>
                </div>
            </div>

            <div class="tip">
                <strong>Malware Analysis Use:</strong> Hash unknown files and search them on VirusTotal, Hybrid Analysis, or other threat intelligence platforms to check for known malware signatures.
            </div>
        </div>

        <!-- XOR Decoder Tool -->
        <div class="tool-panel" id="xor-decoder">
            <div class="tool-header">
                <h2 class="tool-title">XOR Decoder</h2>
                <button class="info-button" onclick="toggleInfo('xor-info')">Info</button>
            </div>

            <div class="info-panel" id="xor-info">
                <strong>Purpose:</strong> XOR (exclusive OR) is one of the most common encryption methods used in malware for obfuscating strings, configuration data, and payloads.
                <br><br>
                <strong>Brute Force Mode:</strong> Tests all 256 single-byte keys (0x00-0xFF) and scores results based on printable ASCII characters. High scores indicate likely decryption success.
            </div>

            <div class="input-group">
                <label>Hex-Encoded Data:</label>
                <textarea id="xor-input" placeholder="48656C6C6F"></textarea>
            </div>

            <div class="input-group">
                <label>XOR Key (hex, e.g., AA or 4142):</label>
                <input type="text" id="xor-key" placeholder="AA">
            </div>

            <div class="button-group">
                <button onclick="xorDecode()">Decode with Key</button>
                <button onclick="xorBruteForce()" class="secondary-button">Brute Force (Single Byte)</button>
            </div>

            <div class="output-section">
                <div class="output-header">
                    <span>Decoded Result</span>
                    <button class="copy-button" onclick="copyToClipboard('xor-output')">Copy</button>
                </div>
                <div class="output-content" id="xor-output">Enter data and key to decode...</div>
            </div>

            <div class="output-section" id="xor-bruteforce-section" style="display: none;">
                <div class="output-header">
                    <span>Top Brute Force Results (sorted by score)</span>
                </div>
                <div class="xor-result-grid" id="xor-bruteforce-results"></div>
            </div>

            <div class="tip">
                <strong>Tip:</strong> Look for readable strings in brute force results. High scores (>70%) usually indicate successful decryption. Multi-byte keys require known plaintext attacks.
            </div>
        </div>

        <!-- Entropy Calculator Tool -->
        <div class="tool-panel" id="entropy">
            <div class="tool-header">
                <h2 class="tool-title">Entropy Calculator</h2>
                <button class="info-button" onclick="toggleInfo('entropy-info')">Info</button>
            </div>

            <div class="info-panel" id="entropy-info">
                <strong>Purpose:</strong> Shannon entropy measures data randomness (0-8 bits per byte). Essential for detecting encryption, compression, or packed malware.
                <br><br>
                <strong>Interpretation:</strong>
                <ul style="margin-top: 10px;">
                    <li><strong>0-3:</strong> Low entropy - Plain text, repetitive data</li>
                    <li><strong>3-6:</strong> Medium entropy - Compressed or structured data</li>
                    <li><strong>6-8:</strong> High entropy - Encrypted or packed (suspicious!)</li>
                </ul>
            </div>

            <div class="input-group">
                <label>Input Type:</label>
                <select id="entropy-input-type">
                    <option value="text">Text</option>
                    <option value="hex">Hex</option>
                </select>
            </div>

            <div class="input-group">
                <label>Data:</label>
                <textarea id="entropy-input" placeholder="Enter text or hex data..."></textarea>
            </div>

            <div class="output-section">
                <div class="output-header">
                    <span>Entropy Analysis</span>
                </div>
                <div class="output-content">
                    <div style="margin-bottom: 15px;">
                        <strong>Shannon Entropy:</strong> <span id="entropy-value" style="color: #d4b5e5; font-size: 1.5em;">-</span> bits/byte
                    </div>
                    <div class="entropy-bar">
                        <div class="entropy-fill" id="entropy-fill" style="width: 0%;">0%</div>
                    </div>
                    <div style="margin-top: 15px; color: #9a7aaa;">
                        <strong>Interpretation:</strong> <span id="entropy-interpretation">Enter data to analyze...</span>
                    </div>
                    <div style="margin-top: 10px; font-size: 0.9em;">
                        <strong>Data Size:</strong> <span id="entropy-size">-</span> bytes
                    </div>
                </div>
            </div>

            <div class="tip">
                <strong>Malware Analysis:</strong> Packed/encrypted malware sections show high entropy (>7.0). Compare entropy across different file sections to find packed code.
            </div>
        </div>

        <!-- IOC Extractor Tool -->
        <div class="tool-panel" id="ioc-extractor">
            <div class="tool-header">
                <h2 class="tool-title">IOC Extractor</h2>
                <button class="info-button" onclick="toggleInfo('ioc-info')">Info</button>
            </div>

            <div class="info-panel" id="ioc-info">
                <strong>Purpose:</strong> Automatically extract Indicators of Compromise (IOCs) from logs, reports, or malware output. IOCs are forensic artifacts that indicate potential intrusions.
                <br><br>
                <strong>Extracted IOCs:</strong> IPv4 addresses, domains, URLs, email addresses, MD5/SHA1/SHA256 hashes.
                <br><br>
                <strong>Defanging:</strong> Converts IOCs to safe format (e.g., malware[.]com, 192.168.1[.]1) to prevent accidental clicks/execution.
            </div>

            <div class="input-group">
                <label>Paste Logs/Text:</label>
                <textarea id="ioc-input" placeholder="Paste logs, PCAP output, malware strings, or any text containing IOCs..." style="min-height: 200px;"></textarea>
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="ioc-defang">
                <label for="ioc-defang">Defang IOCs (safe format)</label>
            </div>

            <div class="button-group">
                <button onclick="extractIOCs()">Extract IOCs</button>
                <button onclick="exportIOCs()" class="secondary-button">Export as List</button>
            </div>

            <div class="output-section">
                <div class="output-header">
                    <span>Extracted IOCs</span>
                </div>
                <div class="ioc-list" id="ioc-output">Enter data to extract IOCs...</div>
            </div>

            <div class="tip">
                <strong>Workflow:</strong> Extract IOCs → Defang for sharing → Search on threat intelligence platforms → Add to blocklists/SIEM alerts.
            </div>
        </div>
    </div>

    <script>
        // Tab switching
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', () => {
                const tabName = button.getAttribute('data-tab');

                document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.tool-panel').forEach(panel => panel.classList.remove('active'));

                button.classList.add('active');
                document.getElementById(tabName).classList.add('active');
            });
        });

        // Info panel toggle
        function toggleInfo(infoId) {
            const infoPanel = document.getElementById(infoId);
            infoPanel.classList.toggle('visible');
        }

        // Copy to clipboard functionality
        function copyToClipboard(elementId) {
            const element = document.getElementById(elementId);
            const text = element.textContent;
            navigator.clipboard.writeText(text).then(() => {
                alert('Copied to clipboard!');
            });
        }

        function copyText(text) {
            navigator.clipboard.writeText(text).then(() => {
                alert('Copied to clipboard!');
            });
        }

        // HEX DECODER
        document.getElementById('hex-input').addEventListener('input', function() {
            const hexInput = this.value;
            decodeHex(hexInput);
        });

        function decodeHex(hexInput) {
            try {
                const cleanHex = hexInput.replace(/[^0-9A-Fa-f]/g, '');

                if (cleanHex.length === 0) {
                    document.getElementById('hex-ascii-output').textContent = 'Enter hex data to decode...';
                    document.getElementById('hex-byte-display').innerHTML = '';
                    return;
                }

                if (cleanHex.length % 2 !== 0) {
                    document.getElementById('hex-ascii-output').textContent = 'Error: Incomplete hex byte (odd number of characters)';
                    return;
                }

                let ascii = '';
                let byteDisplay = '';

                for (let i = 0; i < cleanHex.length; i += 2) {
                    const hexByte = cleanHex.substr(i, 2);
                    const byte = parseInt(hexByte, 16);

                    if (byte >= 32 && byte <= 126) {
                        ascii += String.fromCharCode(byte);
                    } else {
                        ascii += '.';
                    }

                    const char = (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
                    const isPrintable = (byte >= 32 && byte <= 126);
                    const className = isPrintable ? 'printable' : 'non-printable';

                    byteDisplay += `<div class="byte ${className}">
                        <div>0x${hexByte.toUpperCase()}</div>
                        <div>${byte}</div>
                        <div>'${char}'</div>
                    </div>`;
                }

                document.getElementById('hex-ascii-output').textContent = ascii;
                document.getElementById('hex-byte-display').innerHTML = byteDisplay;
            } catch (e) {
                document.getElementById('hex-ascii-output').textContent = 'Error: ' + e.message;
            }
        }

        // BASE64 ENCODER/DECODER
        function base64Encode() {
            const input = document.getElementById('base64-input').value;
            const urlSafe = document.getElementById('base64-urlsafe').checked;

            try {
                let encoded = btoa(input);

                if (urlSafe) {
                    encoded = encoded.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
                }

                document.getElementById('base64-output').textContent = encoded;
            } catch (e) {
                document.getElementById('base64-output').textContent = 'Error: ' + e.message;
            }
        }

        function base64Decode() {
            let input = document.getElementById('base64-input').value.trim();
            const urlSafe = document.getElementById('base64-urlsafe').checked;

            try {
                if (urlSafe) {
                    input = input.replace(/-/g, '+').replace(/_/g, '/');
                    while (input.length % 4) {
                        input += '=';
                    }
                }

                const decoded = atob(input);
                document.getElementById('base64-output').textContent = decoded;
            } catch (e) {
                document.getElementById('base64-output').textContent = 'Error: Invalid Base64 input - ' + e.message;
            }
        }

        // STRING ANALYZER
        function analyzeStrings() {
            const input = document.getElementById('string-input').value;
            const minLength = parseInt(document.getElementById('string-min-length').value) || 4;

            const regex = new RegExp(`[ -~]{${minLength},}`, 'g');
            const matches = input.match(regex) || [];

            const ipRegex = /\b(?:\d{1,3}\.){3}\d{1,3}\b/g;
            const urlRegex = /(?:https?:\/\/|www\.)[^\s]+/gi;
            const domainRegex = /\b(?:[a-z0-9-]+\.)+[a-z]{2,}\b/gi;
            const pathRegex = /(?:[A-Za-z]:\\|\\\\)[^\s<>"|?*]+/g;
            const registryRegex = /HK(?:EY_)?(?:LOCAL_MACHINE|CURRENT_USER|CLASSES_ROOT|USERS|CURRENT_CONFIG)\\[^\s<>"|]+/gi;

            let output = '';
            matches.forEach(str => {
                let highlighted = str;

                highlighted = highlighted.replace(ipRegex, match => `<span class="highlight-ip">${match}</span>`);
                highlighted = highlighted.replace(urlRegex, match => `<span class="highlight-url">${match}</span>`);
                highlighted = highlighted.replace(domainRegex, match => {
                    if (!match.match(ipRegex) && !match.match(urlRegex)) {
                        return `<span class="highlight-url">${match}</span>`;
                    }
                    return match;
                });
                highlighted = highlighted.replace(pathRegex, match => `<span class="highlight-path">${match}</span>`);
                highlighted = highlighted.replace(registryRegex, match => `<span class="highlight-registry">${match}</span>`);

                output += highlighted + '\n';
            });

            document.getElementById('string-count').textContent = matches.length;
            document.getElementById('string-output').innerHTML = output || 'No strings found matching criteria.';
        }

        // HASH CALCULATOR
        document.getElementById('hash-input').addEventListener('input', function() {
            calculateHashes(this.value);
        });

        async function calculateHashes(input) {
            if (!input) {
                document.getElementById('hash-md5').textContent = '-';
                document.getElementById('hash-sha1').textContent = '-';
                document.getElementById('hash-sha256').textContent = '-';
                return;
            }

            const encoder = new TextEncoder();
            const data = encoder.encode(input);

            document.getElementById('hash-md5').textContent = await md5(input);

            const sha1Hash = await crypto.subtle.digest('SHA-1', data);
            document.getElementById('hash-sha1').textContent = arrayBufferToHex(sha1Hash);

            const sha256Hash = await crypto.subtle.digest('SHA-256', data);
            document.getElementById('hash-sha256').textContent = arrayBufferToHex(sha256Hash);
        }

        function arrayBufferToHex(buffer) {
            return Array.from(new Uint8Array(buffer))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }

        async function md5(string) {
            function rotateLeft(value, shift) {
                return (value << shift) | (value >>> (32 - shift));
            }

            function addUnsigned(x, y) {
                return (x + y) >>> 0;
            }

            function md5cycle(x, k) {
                let a = x[0], b = x[1], c = x[2], d = x[3];

                a = ff(a, b, c, d, k[0], 7, 0xd76aa478);
                d = ff(d, a, b, c, k[1], 12, 0xe8c7b756);
                c = ff(c, d, a, b, k[2], 17, 0x242070db);
                b = ff(b, c, d, a, k[3], 22, 0xc1bdceee);
                a = ff(a, b, c, d, k[4], 7, 0xf57c0faf);
                d = ff(d, a, b, c, k[5], 12, 0x4787c62a);
                c = ff(c, d, a, b, k[6], 17, 0xa8304613);
                b = ff(b, c, d, a, k[7], 22, 0xfd469501);
                a = ff(a, b, c, d, k[8], 7, 0x698098d8);
                d = ff(d, a, b, c, k[9], 12, 0x8b44f7af);
                c = ff(c, d, a, b, k[10], 17, 0xffff5bb1);
                b = ff(b, c, d, a, k[11], 22, 0x895cd7be);
                a = ff(a, b, c, d, k[12], 7, 0x6b901122);
                d = ff(d, a, b, c, k[13], 12, 0xfd987193);
                c = ff(c, d, a, b, k[14], 17, 0xa679438e);
                b = ff(b, c, d, a, k[15], 22, 0x49b40821);

                a = gg(a, b, c, d, k[1], 5, 0xf61e2562);
                d = gg(d, a, b, c, k[6], 9, 0xc040b340);
                c = gg(c, d, a, b, k[11], 14, 0x265e5a51);
                b = gg(b, c, d, a, k[0], 20, 0xe9b6c7aa);
                a = gg(a, b, c, d, k[5], 5, 0xd62f105d);
                d = gg(d, a, b, c, k[10], 9, 0x02441453);
                c = gg(c, d, a, b, k[15], 14, 0xd8a1e681);
                b = gg(b, c, d, a, k[4], 20, 0xe7d3fbc8);
                a = gg(a, b, c, d, k[9], 5, 0x21e1cde6);
                d = gg(d, a, b, c, k[14], 9, 0xc33707d6);
                c = gg(c, d, a, b, k[3], 14, 0xf4d50d87);
                b = gg(b, c, d, a, k[8], 20, 0x455a14ed);
                a = gg(a, b, c, d, k[13], 5, 0xa9e3e905);
                d = gg(d, a, b, c, k[2], 9, 0xfcefa3f8);
                c = gg(c, d, a, b, k[7], 14, 0x676f02d9);
                b = gg(b, c, d, a, k[12], 20, 0x8d2a4c8a);

                a = hh(a, b, c, d, k[5], 4, 0xfffa3942);
                d = hh(d, a, b, c, k[8], 11, 0x8771f681);
                c = hh(c, d, a, b, k[11], 16, 0x6d9d6122);
                b = hh(b, c, d, a, k[14], 23, 0xfde5380c);
                a = hh(a, b, c, d, k[1], 4, 0xa4beea44);
                d = hh(d, a, b, c, k[4], 11, 0x4bdecfa9);
                c = hh(c, d, a, b, k[7], 16, 0xf6bb4b60);
                b = hh(b, c, d, a, k[10], 23, 0xbebfbc70);
                a = hh(a, b, c, d, k[13], 4, 0x289b7ec6);
                d = hh(d, a, b, c, k[0], 11, 0xeaa127fa);
                c = hh(c, d, a, b, k[3], 16, 0xd4ef3085);
                b = hh(b, c, d, a, k[6], 23, 0x04881d05);
                a = hh(a, b, c, d, k[9], 4, 0xd9d4d039);
                d = hh(d, a, b, c, k[12], 11, 0xe6db99e5);
                c = hh(c, d, a, b, k[15], 16, 0x1fa27cf8);
                b = hh(b, c, d, a, k[2], 23, 0xc4ac5665);

                a = ii(a, b, c, d, k[0], 6, 0xf4292244);
                d = ii(d, a, b, c, k[7], 10, 0x432aff97);
                c = ii(c, d, a, b, k[14], 15, 0xab9423a7);
                b = ii(b, c, d, a, k[5], 21, 0xfc93a039);
                a = ii(a, b, c, d, k[12], 6, 0x655b59c3);
                d = ii(d, a, b, c, k[3], 10, 0x8f0ccc92);
                c = ii(c, d, a, b, k[10], 15, 0xffeff47d);
                b = ii(b, c, d, a, k[1], 21, 0x85845dd1);
                a = ii(a, b, c, d, k[8], 6, 0x6fa87e4f);
                d = ii(d, a, b, c, k[15], 10, 0xfe2ce6e0);
                c = ii(c, d, a, b, k[6], 15, 0xa3014314);
                b = ii(b, c, d, a, k[13], 21, 0x4e0811a1);
                a = ii(a, b, c, d, k[4], 6, 0xf7537e82);
                d = ii(d, a, b, c, k[11], 10, 0xbd3af235);
                c = ii(c, d, a, b, k[2], 15, 0x2ad7d2bb);
                b = ii(b, c, d, a, k[9], 21, 0xeb86d391);

                x[0] = addUnsigned(a, x[0]);
                x[1] = addUnsigned(b, x[1]);
                x[2] = addUnsigned(c, x[2]);
                x[3] = addUnsigned(d, x[3]);
            }

            function cmn(q, a, b, x, s, t) {
                a = addUnsigned(addUnsigned(a, q), addUnsigned(x, t));
                return addUnsigned(rotateLeft(a, s), b);
            }

            function ff(a, b, c, d, x, s, t) {
                return cmn((b & c) | ((~b) & d), a, b, x, s, t);
            }

            function gg(a, b, c, d, x, s, t) {
                return cmn((b & d) | (c & (~d)), a, b, x, s, t);
            }

            function hh(a, b, c, d, x, s, t) {
                return cmn(b ^ c ^ d, a, b, x, s, t);
            }

            function ii(a, b, c, d, x, s, t) {
                return cmn(c ^ (b | (~d)), a, b, x, s, t);
            }

            const encoder = new TextEncoder();
            const data = encoder.encode(string);
            const msgLen = data.length;
            const paddingLen = (((msgLen + 8) >>> 6) + 1) << 6;
            const msg = new Uint8Array(paddingLen);
            msg.set(data);
            msg[msgLen] = 0x80;

            const lenBits = msgLen * 8;
            for (let i = 0; i < 8; i++) {
                msg[paddingLen - 8 + i] = (lenBits >>> (i * 8)) & 0xff;
            }

            const x = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476];

            for (let i = 0; i < msg.length; i += 64) {
                const block = new Uint32Array(16);
                for (let j = 0; j < 16; j++) {
                    block[j] = msg[i + j * 4] |
                              (msg[i + j * 4 + 1] << 8) |
                              (msg[i + j * 4 + 2] << 16) |
                              (msg[i + j * 4 + 3] << 24);
                }
                md5cycle(x, block);
            }

            let result = '';
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    result += ((x[i] >>> (j * 8)) & 0xff).toString(16).padStart(2, '0');
                }
            }
            return result;
        }

        // XOR DECODER
        function xorDecode() {
            const hexInput = document.getElementById('xor-input').value.replace(/[^0-9A-Fa-f]/g, '');
            const keyInput = document.getElementById('xor-key').value.replace(/[^0-9A-Fa-f]/g, '');

            if (!hexInput || !keyInput) {
                document.getElementById('xor-output').textContent = 'Please enter both data and key.';
                return;
            }

            if (hexInput.length % 2 !== 0 || keyInput.length % 2 !== 0) {
                document.getElementById('xor-output').textContent = 'Error: Incomplete hex bytes.';
                return;
            }

            const data = hexToBytes(hexInput);
            const key = hexToBytes(keyInput);

            let result = '';
            for (let i = 0; i < data.length; i++) {
                const xored = data[i] ^ key[i % key.length];
                result += String.fromCharCode(xored);
            }

            document.getElementById('xor-output').textContent = result;
            document.getElementById('xor-bruteforce-section').style.display = 'none';
        }

        function xorBruteForce() {
            const hexInput = document.getElementById('xor-input').value.replace(/[^0-9A-Fa-f]/g, '');

            if (!hexInput) {
                document.getElementById('xor-output').textContent = 'Please enter data to brute force.';
                return;
            }

            const data = hexToBytes(hexInput);
            const results = [];

            for (let key = 0; key < 256; key++) {
                let decoded = '';
                let printableCount = 0;

                for (let i = 0; i < data.length; i++) {
                    const xored = data[i] ^ key;
                    decoded += String.fromCharCode(xored);
                    if (xored >= 32 && xored <= 126) {
                        printableCount++;
                    }
                }

                const score = (printableCount / data.length) * 100;
                results.push({ key, decoded, score });
            }

            results.sort((a, b) => b.score - a.score);

            let output = '';
            for (let i = 0; i < Math.min(20, results.length); i++) {
                const r = results[i];
                const preview = r.decoded.substring(0, 100);
                output += `<div class="xor-result-item">
                    <div class="xor-key">Key: 0x${r.key.toString(16).padStart(2, '0').toUpperCase()} (${r.key})</div>
                    <div class="xor-score">Score: ${r.score.toFixed(1)}% printable</div>
                    <div class="xor-preview">${escapeHtml(preview)}${r.decoded.length > 100 ? '...' : ''}</div>
                </div>`;
            }

            document.getElementById('xor-bruteforce-results').innerHTML = output;
            document.getElementById('xor-bruteforce-section').style.display = 'block';
            document.getElementById('xor-output').textContent = 'Brute force complete. Top results shown below (sorted by printable character score).';
        }

        function hexToBytes(hex) {
            const bytes = [];
            for (let i = 0; i < hex.length; i += 2) {
                bytes.push(parseInt(hex.substr(i, 2), 16));
            }
            return bytes;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ENTROPY CALCULATOR
        document.getElementById('entropy-input').addEventListener('input', calculateEntropy);
        document.getElementById('entropy-input-type').addEventListener('change', calculateEntropy);

        function calculateEntropy() {
            const input = document.getElementById('entropy-input').value;
            const inputType = document.getElementById('entropy-input-type').value;

            if (!input) {
                document.getElementById('entropy-value').textContent = '-';
                document.getElementById('entropy-fill').style.width = '0%';
                document.getElementById('entropy-fill').textContent = '0%';
                document.getElementById('entropy-interpretation').textContent = 'Enter data to analyze...';
                document.getElementById('entropy-size').textContent = '-';
                return;
            }

            let data;
            if (inputType === 'hex') {
                const cleanHex = input.replace(/[^0-9A-Fa-f]/g, '');
                if (cleanHex.length % 2 !== 0) {
                    document.getElementById('entropy-interpretation').textContent = 'Error: Incomplete hex byte.';
                    return;
                }
                data = hexToBytes(cleanHex);
            } else {
                const encoder = new TextEncoder();
                data = Array.from(encoder.encode(input));
            }

            const freq = new Array(256).fill(0);
            for (const byte of data) {
                freq[byte]++;
            }

            let entropy = 0;
            for (const count of freq) {
                if (count > 0) {
                    const p = count / data.length;
                    entropy -= p * Math.log2(p);
                }
            }

            const entropyPercent = (entropy / 8) * 100;

            document.getElementById('entropy-value').textContent = entropy.toFixed(4);
            document.getElementById('entropy-fill').style.width = entropyPercent + '%';
            document.getElementById('entropy-fill').textContent = entropyPercent.toFixed(1) + '%';
            document.getElementById('entropy-size').textContent = data.length;

            let interpretation = '';
            if (entropy < 3) {
                interpretation = 'Low entropy - Likely plain text or highly repetitive data.';
            } else if (entropy < 6) {
                interpretation = 'Medium entropy - Possibly compressed or structured data.';
            } else {
                interpretation = 'High entropy - Likely encrypted or packed. SUSPICIOUS for malware analysis!';
            }

            document.getElementById('entropy-interpretation').textContent = interpretation;
        }

        // IOC EXTRACTOR
        let extractedIOCs = {};

        function extractIOCs() {
            const input = document.getElementById('ioc-input').value;
            const defang = document.getElementById('ioc-defang').checked;

            extractedIOCs = {
                ips: [],
                domains: [],
                urls: [],
                emails: [],
                hashes: {
                    md5: [],
                    sha1: [],
                    sha256: []
                }
            };

            const ipRegex = /\b(?:\d{1,3}\.){3}\d{1,3}\b/g;
            const urlRegex = /(?:https?:\/\/|ftp:\/\/)[^\s<>"\]]+/gi;
            const domainRegex = /\b(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\.)+[a-z]{2,}\b/gi;
            const emailRegex = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g;
            const md5Regex = /\b[a-f0-9]{32}\b/gi;
            const sha1Regex = /\b[a-f0-9]{40}\b/gi;
            const sha256Regex = /\b[a-f0-9]{64}\b/gi;

            extractedIOCs.ips = [...new Set(input.match(ipRegex) || [])];
            extractedIOCs.urls = [...new Set(input.match(urlRegex) || [])];

            const allDomains = input.match(domainRegex) || [];
            const urlDomains = new Set(extractedIOCs.urls.map(url => {
                try {
                    return new URL(url).hostname;
                } catch {
                    return null;
                }
            }).filter(Boolean));

            extractedIOCs.domains = [...new Set(allDomains.filter(domain => !urlDomains.has(domain)))];
            extractedIOCs.emails = [...new Set(input.match(emailRegex) || [])];
            extractedIOCs.hashes.md5 = [...new Set(input.match(md5Regex) || [])];
            extractedIOCs.hashes.sha1 = [...new Set(input.match(sha1Regex) || [])];
            extractedIOCs.hashes.sha256 = [...new Set(input.match(sha256Regex) || [])];

            if (defang) {
                extractedIOCs.ips = extractedIOCs.ips.map(ip => ip.replace(/\./g, '[.]'));
                extractedIOCs.domains = extractedIOCs.domains.map(d => d.replace(/\./g, '[.]'));
                extractedIOCs.urls = extractedIOCs.urls.map(u => u.replace(/\./g, '[.]').replace(/http/gi, 'hxxp'));
                extractedIOCs.emails = extractedIOCs.emails.map(e => e.replace(/\./g, '[.]').replace(/@/g, '[@]'));
            }

            displayIOCs();
        }

        function displayIOCs() {
            let output = '';

            if (extractedIOCs.ips.length > 0) {
                output += '<div class="ioc-category"><div class="ioc-category-title">IP Addresses (' + extractedIOCs.ips.length + ')</div>';
                extractedIOCs.ips.forEach(ip => {
                    output += '<div class="ioc-item">' + ip + '</div>';
                });
                output += '</div>';
            }

            if (extractedIOCs.urls.length > 0) {
                output += '<div class="ioc-category"><div class="ioc-category-title">URLs (' + extractedIOCs.urls.length + ')</div>';
                extractedIOCs.urls.forEach(url => {
                    output += '<div class="ioc-item">' + url + '</div>';
                });
                output += '</div>';
            }

            if (extractedIOCs.domains.length > 0) {
                output += '<div class="ioc-category"><div class="ioc-category-title">Domains (' + extractedIOCs.domains.length + ')</div>';
                extractedIOCs.domains.forEach(domain => {
                    output += '<div class="ioc-item">' + domain + '</div>';
                });
                output += '</div>';
            }

            if (extractedIOCs.emails.length > 0) {
                output += '<div class="ioc-category"><div class="ioc-category-title">Email Addresses (' + extractedIOCs.emails.length + ')</div>';
                extractedIOCs.emails.forEach(email => {
                    output += '<div class="ioc-item">' + email + '</div>';
                });
                output += '</div>';
            }

            if (extractedIOCs.hashes.md5.length > 0) {
                output += '<div class="ioc-category"><div class="ioc-category-title">MD5 Hashes (' + extractedIOCs.hashes.md5.length + ')</div>';
                extractedIOCs.hashes.md5.forEach(hash => {
                    output += '<div class="ioc-item">' + hash + '</div>';
                });
                output += '</div>';
            }

            if (extractedIOCs.hashes.sha1.length > 0) {
                output += '<div class="ioc-category"><div class="ioc-category-title">SHA-1 Hashes (' + extractedIOCs.hashes.sha1.length + ')</div>';
                extractedIOCs.hashes.sha1.forEach(hash => {
                    output += '<div class="ioc-item">' + hash + '</div>';
                });
                output += '</div>';
            }

            if (extractedIOCs.hashes.sha256.length > 0) {
                output += '<div class="ioc-category"><div class="ioc-category-title">SHA-256 Hashes (' + extractedIOCs.hashes.sha256.length + ')</div>';
                extractedIOCs.hashes.sha256.forEach(hash => {
                    output += '<div class="ioc-item">' + hash + '</div>';
                });
                output += '</div>';
            }

            if (output === '') {
                output = '<div style="color: #9a7aaa;">No IOCs found in input.</div>';
            }

            document.getElementById('ioc-output').innerHTML = output;
        }

        function exportIOCs() {
            let exportText = 'EXTRACTED IOCs\n';
            exportText += '='.repeat(50) + '\n\n';

            if (extractedIOCs.ips && extractedIOCs.ips.length > 0) {
                exportText += 'IP ADDRESSES:\n';
                exportText += extractedIOCs.ips.join('\n') + '\n\n';
            }

            if (extractedIOCs.urls && extractedIOCs.urls.length > 0) {
                exportText += 'URLs:\n';
                exportText += extractedIOCs.urls.join('\n') + '\n\n';
            }

            if (extractedIOCs.domains && extractedIOCs.domains.length > 0) {
                exportText += 'DOMAINS:\n';
                exportText += extractedIOCs.domains.join('\n') + '\n\n';
            }

            if (extractedIOCs.emails && extractedIOCs.emails.length > 0) {
                exportText += 'EMAIL ADDRESSES:\n';
                exportText += extractedIOCs.emails.join('\n') + '\n\n';
            }

            if (extractedIOCs.hashes) {
                if (extractedIOCs.hashes.md5.length > 0) {
                    exportText += 'MD5 HASHES:\n';
                    exportText += extractedIOCs.hashes.md5.join('\n') + '\n\n';
                }
                if (extractedIOCs.hashes.sha1.length > 0) {
                    exportText += 'SHA-1 HASHES:\n';
                    exportText += extractedIOCs.hashes.sha1.join('\n') + '\n\n';
                }
                if (extractedIOCs.hashes.sha256.length > 0) {
                    exportText += 'SHA-256 HASHES:\n';
                    exportText += extractedIOCs.hashes.sha256.join('\n') + '\n\n';
                }
            }

            const blob = new Blob([exportText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'iocs_export.txt';
            a.click();
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>