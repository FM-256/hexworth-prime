<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IDS/IPS & Firewall Evasion Lab | Hexworth Prime - Dark Arts Vault</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #a855f7;
            --accent: #dc2626;
            --bg: #0a0a0f;
            --bg-secondary: #13131a;
            --bg-tertiary: #1a1a24;
            --text: #e4e4e7;
            --text-secondary: #a1a1aa;
            --border: #27272f;
            --success: #10b981;
            --warning: #f59e0b;
            --info: #3b82f6;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--bg) 0%, #0f0f1a 100%);
            color: var(--text);
            line-height: 1.6;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid var(--border);
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--primary), var(--accent), var(--primary));
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        .header h1 {
            font-size: 2.5em;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .header p {
            color: var(--text-secondary);
            font-size: 1.1em;
        }

        /* Progress Bar */
        .progress-container {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid var(--border);
            margin-bottom: 30px;
        }

        .progress-bar {
            width: 100%;
            height: 25px;
            background: var(--bg-tertiary);
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            width: 0%;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 10px;
            color: white;
            font-weight: bold;
            font-size: 0.85em;
        }

        .xp-display {
            text-align: center;
            margin-top: 10px;
            font-size: 1.2em;
            color: var(--primary);
            font-weight: bold;
        }

        /* Navigation Tabs */
        .nav-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .nav-tab {
            padding: 12px 24px;
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .nav-tab:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
        }

        .nav-tab.active {
            background: linear-gradient(135deg, var(--primary), var(--accent));
            border-color: var(--primary);
            color: white;
        }

        /* Content Sections */
        .content-section {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        .content-section.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 20px;
        }

        .card h2 {
            color: var(--primary);
            margin-bottom: 15px;
            font-size: 1.8em;
        }

        .card h3 {
            color: var(--accent);
            margin: 20px 0 10px 0;
            font-size: 1.3em;
        }

        /* Network Diagram */
        .network-diagram {
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            border-radius: 10px;
            padding: 30px;
            margin: 20px 0;
            min-height: 400px;
            position: relative;
        }

        .network-node {
            position: absolute;
            background: var(--bg-secondary);
            border: 2px solid var(--primary);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .network-node:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px var(--primary);
        }

        .network-node.active {
            border-color: var(--accent);
            box-shadow: 0 0 30px var(--accent);
        }

        .network-line {
            position: absolute;
            height: 2px;
            background: var(--border);
            transform-origin: 0 0;
        }

        .network-line.active {
            background: var(--primary);
            box-shadow: 0 0 10px var(--primary);
        }

        /* Snort Rule Builder */
        .rule-builder {
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .rule-input-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .input-wrapper {
            display: flex;
            flex-direction: column;
        }

        .input-wrapper label {
            color: var(--text-secondary);
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .input-wrapper input,
        .input-wrapper select {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 5px;
            padding: 10px;
            color: var(--text);
            font-size: 1em;
        }

        .input-wrapper input:focus,
        .input-wrapper select:focus {
            outline: none;
            border-color: var(--primary);
        }

        .rule-output {
            background: #000;
            border: 1px solid var(--primary);
            border-radius: 5px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            color: #0f0;
            margin: 15px 0;
            min-height: 60px;
            word-wrap: break-word;
        }

        .syntax-highlight {
            color: var(--primary);
        }

        .syntax-keyword {
            color: #f59e0b;
        }

        .syntax-string {
            color: #10b981;
        }

        /* Evasion Simulator */
        .evasion-simulator {
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .packet-visualization {
            background: #000;
            border: 1px solid var(--primary);
            border-radius: 5px;
            padding: 20px;
            margin: 20px 0;
            min-height: 200px;
            position: relative;
            overflow: hidden;
        }

        .packet {
            position: absolute;
            width: 40px;
            height: 40px;
            background: var(--primary);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.8em;
            transition: all 0.5s ease;
        }

        .packet.fragmented {
            background: var(--accent);
            width: 20px;
            height: 20px;
        }

        .packet.decoy {
            background: var(--text-secondary);
            opacity: 0.6;
        }

        .ids-detector {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 80px;
            height: 100px;
            background: var(--bg-secondary);
            border: 2px solid var(--info);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        .ids-detector.alerted {
            border-color: var(--accent);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 10px var(--accent); }
            50% { box-shadow: 0 0 30px var(--accent); }
        }

        /* Alert Classification */
        .alert-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .alert-card {
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .alert-card:hover {
            border-color: var(--primary);
            transform: translateY(-5px);
        }

        .alert-card.correct {
            border-color: var(--success);
            background: rgba(16, 185, 129, 0.1);
        }

        .alert-card.incorrect {
            border-color: var(--accent);
            background: rgba(220, 38, 38, 0.1);
        }

        .classification-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .classify-btn {
            padding: 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 5px;
            color: var(--text);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }

        .classify-btn:hover {
            background: var(--primary);
            border-color: var(--primary);
        }

        /* TTL Attack Animator */
        .ttl-animator {
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .ttl-network {
            background: #000;
            border: 1px solid var(--primary);
            border-radius: 5px;
            padding: 30px;
            margin: 20px 0;
            min-height: 300px;
            position: relative;
        }

        .ttl-hop {
            position: absolute;
            width: 60px;
            height: 60px;
            background: var(--bg-secondary);
            border: 2px solid var(--info);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            font-size: 0.8em;
        }

        .ttl-packet {
            position: absolute;
            width: 30px;
            height: 30px;
            background: var(--accent);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.7em;
            transition: all 1s ease;
        }

        /* Firewall Rule Analyzer */
        .rule-analyzer {
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .rule-input {
            width: 100%;
            background: #000;
            border: 1px solid var(--primary);
            border-radius: 5px;
            padding: 15px;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            min-height: 100px;
            resize: vertical;
        }

        .rule-analysis {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 5px;
            padding: 15px;
            margin-top: 15px;
            min-height: 100px;
        }

        .analysis-item {
            padding: 10px;
            margin: 5px 0;
            border-left: 3px solid var(--primary);
            background: var(--bg-tertiary);
        }

        /* Buttons */
        .btn {
            padding: 12px 30px;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(168, 85, 247, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: var(--bg-secondary);
            border: 2px solid var(--border);
        }

        .btn-secondary:hover {
            border-color: var(--primary);
            background: var(--bg-tertiary);
        }

        /* Quiz */
        .quiz-container {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 20px;
        }

        .question {
            margin-bottom: 30px;
        }

        .question h3 {
            color: var(--primary);
            margin-bottom: 15px;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .option {
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .option:hover {
            border-color: var(--primary);
            transform: translateX(5px);
        }

        .option.selected {
            border-color: var(--primary);
            background: rgba(168, 85, 247, 0.1);
        }

        .option.correct {
            border-color: var(--success);
            background: rgba(16, 185, 129, 0.1);
        }

        .option.incorrect {
            border-color: var(--accent);
            background: rgba(220, 38, 38, 0.1);
        }

        .quiz-results {
            background: var(--bg-tertiary);
            border: 2px solid var(--primary);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            margin-top: 20px;
        }

        .quiz-results h2 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        /* Info Boxes */
        .info-box {
            background: rgba(59, 130, 246, 0.1);
            border-left: 4px solid var(--info);
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
        }

        .warning-box {
            background: rgba(245, 158, 11, 0.1);
            border-left: 4px solid var(--warning);
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
        }

        .danger-box {
            background: rgba(220, 38, 38, 0.1);
            border-left: 4px solid var(--accent);
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
        }

        .success-box {
            background: rgba(16, 185, 129, 0.1);
            border-left: 4px solid var(--success);
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
        }

        /* Code Blocks */
        .code-block {
            background: #000;
            border: 1px solid var(--primary);
            border-radius: 5px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            color: #0f0;
            overflow-x: auto;
            margin: 15px 0;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8em;
            }

            .nav-tabs {
                flex-direction: column;
            }

            .rule-input-group {
                grid-template-columns: 1fr;
            }
        }

        /* Lists */
        ul {
            margin-left: 20px;
            margin-top: 10px;
        }

        li {
            margin: 8px 0;
        }

        /* Table */
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        .comparison-table th,
        .comparison-table td {
            border: 1px solid var(--border);
            padding: 12px;
            text-align: left;
        }

        .comparison-table th {
            background: var(--bg-tertiary);
            color: var(--primary);
            font-weight: bold;
        }

        .comparison-table tr:hover {
            background: rgba(168, 85, 247, 0.05);
        }

        /* Technique Cards */
        .technique-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .technique-card {
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            border-radius: 10px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .technique-card:hover {
            border-color: var(--accent);
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(220, 38, 38, 0.2);
        }

        .technique-card h4 {
            color: var(--accent);
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>IDS/IPS & Firewall Evasion Lab</h1>
            <p>Master intrusion detection systems, evasion techniques, and defensive countermeasures</p>
        </div>

        <div class="progress-container">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill">0%</div>
            </div>
            <div class="xp-display" id="xpDisplay">0 / 75 XP</div>
        </div>

        <div class="nav-tabs">
            <div class="nav-tab active" onclick="switchTab('theory')">Theory</div>
            <div class="nav-tab" onclick="switchTab('network')">Network Diagram</div>
            <div class="nav-tab" onclick="switchTab('snort')">Snort Rule Builder</div>
            <div class="nav-tab" onclick="switchTab('evasion')">Evasion Simulator</div>
            <div class="nav-tab" onclick="switchTab('alerts')">Alert Classification</div>
            <div class="nav-tab" onclick="switchTab('ttl')">TTL Attack</div>
            <div class="nav-tab" onclick="switchTab('firewall')">Firewall Analyzer</div>
            <div class="nav-tab" onclick="switchTab('quiz')">Final Quiz</div>
        </div>

        <!-- Theory Section -->
        <div id="theory" class="content-section active">
            <div class="card">
                <h2>IDS vs IPS: Understanding the Fundamentals</h2>

                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>IDS (Intrusion Detection System)</th>
                            <th>IPS (Intrusion Prevention System)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Primary Function</strong></td>
                            <td>Detects and alerts on suspicious activity</td>
                            <td>Detects AND blocks malicious traffic</td>
                        </tr>
                        <tr>
                            <td><strong>Deployment</strong></td>
                            <td>Out-of-band (monitoring mode)</td>
                            <td>Inline (traffic passes through)</td>
                        </tr>
                        <tr>
                            <td><strong>Response</strong></td>
                            <td>Passive - generates alerts</td>
                            <td>Active - drops packets, blocks IPs</td>
                        </tr>
                        <tr>
                            <td><strong>Impact on Traffic</strong></td>
                            <td>No impact (monitor only)</td>
                            <td>Can introduce latency</td>
                        </tr>
                        <tr>
                            <td><strong>False Positive Risk</strong></td>
                            <td>Alert fatigue</td>
                            <td>Blocking legitimate traffic</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Network-Based vs Host-Based</h3>
                <div class="technique-grid">
                    <div class="technique-card">
                        <h4>NIDS/NIPS (Network)</h4>
                        <ul>
                            <li>Monitors network traffic at strategic points</li>
                            <li>Analyzes packet headers and payloads</li>
                            <li>Protects multiple hosts simultaneously</li>
                            <li>Examples: Snort, Suricata, Zeek</li>
                            <li>Deployment: Span ports, network taps</li>
                        </ul>
                    </div>
                    <div class="technique-card">
                        <h4>HIDS/HIPS (Host)</h4>
                        <ul>
                            <li>Installed on individual systems</li>
                            <li>Monitors system calls, file integrity, logs</li>
                            <li>Can detect local privilege escalation</li>
                            <li>Examples: OSSEC, Tripwire, SELinux</li>
                            <li>Sees encrypted traffic after decryption</li>
                        </ul>
                    </div>
                </div>

                <h3>Alert Classification Matrix</h3>
                <div class="info-box">
                    <strong>True Positive (TP):</strong> Attack occurred AND IDS detected it ‚úì<br>
                    <strong>False Positive (FP):</strong> No attack occurred BUT IDS alerted ‚úó<br>
                    <strong>True Negative (TN):</strong> No attack occurred AND no alert ‚úì<br>
                    <strong>False Negative (FN):</strong> Attack occurred BUT IDS missed it ‚úó‚úó
                </div>

                <div class="danger-box">
                    <strong>False Negatives are the most dangerous</strong> - attackers succeed undetected. False Positives cause alert fatigue and waste resources.
                </div>

                <h3>Major IDS/IPS Solutions</h3>
                <div class="code-block">
<strong>Snort</strong> - Open-source NIDS/NIPS, signature-based detection
<strong>Suricata</strong> - Multi-threaded IDS/IPS, protocol analysis
<strong>Zeek (Bro)</strong> - Network analysis framework, scripting capability
<strong>AlienVault OSSIM</strong> - Unified security management platform
<strong>YARA</strong> - Pattern matching for malware detection
<strong>Security Onion</strong> - Complete IDS distribution
                </div>

                <h3>Firewall Types & Technologies</h3>
                <div class="technique-grid">
                    <div class="technique-card">
                        <h4>Packet Filtering</h4>
                        <p>First generation - examines header information (IP, port, protocol). Fast but limited context awareness.</p>
                    </div>
                    <div class="technique-card">
                        <h4>Stateful Inspection</h4>
                        <p>Tracks connection state, remembers sessions. Can validate TCP handshakes and track return traffic.</p>
                    </div>
                    <div class="technique-card">
                        <h4>Application Layer</h4>
                        <p>Deep packet inspection, understands protocols (HTTP, FTP, DNS). Can filter based on content.</p>
                    </div>
                    <div class="technique-card">
                        <h4>Next-Gen Firewalls (NGFW)</h4>
                        <p>Combines traditional firewall with IPS, application awareness, threat intelligence, and SSL inspection.</p>
                    </div>
                </div>

                <h3>Honeypots & Deception Systems</h3>
                <div class="warning-box">
                    <strong>Honeypots</strong> are intentionally vulnerable systems designed to attract and detect attackers. They provide early warning and intelligence about attack methods.
                    <ul>
                        <li><strong>Low-interaction:</strong> Simulated services (honeyd)</li>
                        <li><strong>High-interaction:</strong> Real systems with monitoring (Honeynets)</li>
                        <li><strong>Production honeypots:</strong> Detect internal threats</li>
                        <li><strong>Research honeypots:</strong> Collect attack data</li>
                    </ul>
                </div>

                <button class="btn" onclick="completeSection('theory', 10)">Mark Theory Complete</button>
            </div>
        </div>

        <!-- Network Diagram Section -->
        <div id="network" class="content-section">
            <div class="card">
                <h2>IDS/IPS Network Placement</h2>
                <p>Click on network components to learn about IDS/IPS placement strategies</p>

                <div class="network-diagram" id="networkDiagram">
                    <!-- Nodes will be positioned absolutely -->
                    <div class="network-node" style="left: 50px; top: 150px;" onclick="highlightNode(0)" id="node0">
                        <div>üåê</div>
                        <div style="font-size: 0.9em;">Internet</div>
                    </div>

                    <div class="network-node" style="left: 250px; top: 150px;" onclick="highlightNode(1)" id="node1">
                        <div>üõ°Ô∏è</div>
                        <div style="font-size: 0.9em;">Perimeter FW</div>
                    </div>

                    <div class="network-node" style="left: 250px; top: 50px;" onclick="highlightNode(2)" id="node2">
                        <div>üîç</div>
                        <div style="font-size: 0.9em;">NIDS #1</div>
                        <div style="font-size: 0.8em; color: #10b981;">External</div>
                    </div>

                    <div class="network-node" style="left: 450px; top: 150px;" onclick="highlightNode(3)" id="node3">
                        <div>üñ•Ô∏è</div>
                        <div style="font-size: 0.9em;">DMZ</div>
                    </div>

                    <div class="network-node" style="left: 650px; top: 150px;" onclick="highlightNode(4)" id="node4">
                        <div>üõ°Ô∏è</div>
                        <div style="font-size: 0.9em;">Internal FW</div>
                    </div>

                    <div class="network-node" style="left: 650px; top: 50px;" onclick="highlightNode(5)" id="node5">
                        <div>üö®</div>
                        <div style="font-size: 0.9em;">NIPS #2</div>
                        <div style="font-size: 0.8em; color: #dc2626;">Inline</div>
                    </div>

                    <div class="network-node" style="left: 850px; top: 150px;" onclick="highlightNode(6)" id="node6">
                        <div>üíº</div>
                        <div style="font-size: 0.9em;">Internal LAN</div>
                    </div>

                    <div class="network-node" style="left: 850px; top: 250px;" onclick="highlightNode(7)" id="node7">
                        <div>üñ•Ô∏è</div>
                        <div style="font-size: 0.9em;">HIDS</div>
                        <div style="font-size: 0.8em; color: #3b82f6;">Host-based</div>
                    </div>

                    <div class="network-node" style="left: 450px; top: 250px;" onclick="highlightNode(8)" id="node8">
                        <div>üçØ</div>
                        <div style="font-size: 0.9em;">Honeypot</div>
                    </div>
                </div>

                <div class="info-box" id="nodeInfo">
                    <strong>Select a component</strong> to view its role in network security architecture.
                </div>

                <button class="btn" onclick="completeSection('network', 8)">Complete Network Review</button>
            </div>
        </div>

        <!-- Snort Rule Builder Section -->
        <div id="snort" class="content-section">
            <div class="card">
                <h2>Snort Rule Builder</h2>
                <p>Create custom Snort IDS rules and understand the syntax</p>

                <div class="info-box">
                    <strong>Snort Rule Structure:</strong><br>
                    <code>&lt;action&gt; &lt;protocol&gt; &lt;src_ip&gt; &lt;src_port&gt; &lt;direction&gt; &lt;dst_ip&gt; &lt;dst_port&gt; (rule options)</code>
                </div>

                <div class="rule-builder">
                    <h3>Rule Configuration</h3>
                    <div class="rule-input-group">
                        <div class="input-wrapper">
                            <label>Action</label>
                            <select id="ruleAction" onchange="updateSnortRule()">
                                <option value="alert">alert</option>
                                <option value="log">log</option>
                                <option value="pass">pass</option>
                                <option value="drop">drop (IPS)</option>
                                <option value="reject">reject (IPS)</option>
                            </select>
                        </div>

                        <div class="input-wrapper">
                            <label>Protocol</label>
                            <select id="ruleProtocol" onchange="updateSnortRule()">
                                <option value="tcp">TCP</option>
                                <option value="udp">UDP</option>
                                <option value="icmp">ICMP</option>
                                <option value="ip">IP</option>
                            </select>
                        </div>

                        <div class="input-wrapper">
                            <label>Source IP</label>
                            <input type="text" id="ruleSrcIp" value="any" oninput="updateSnortRule()" placeholder="any, 192.168.1.0/24">
                        </div>

                        <div class="input-wrapper">
                            <label>Source Port</label>
                            <input type="text" id="ruleSrcPort" value="any" oninput="updateSnortRule()" placeholder="any, 80, 1:1024">
                        </div>

                        <div class="input-wrapper">
                            <label>Direction</label>
                            <select id="ruleDirection" onchange="updateSnortRule()">
                                <option value="->"selected>-&gt; (one way)</option>
                                <option value="<>">&lt;&gt; (bidirectional)</option>
                            </select>
                        </div>

                        <div class="input-wrapper">
                            <label>Destination IP</label>
                            <input type="text" id="ruleDstIp" value="any" oninput="updateSnortRule()" placeholder="any, $HOME_NET">
                        </div>

                        <div class="input-wrapper">
                            <label>Destination Port</label>
                            <input type="text" id="ruleDstPort" value="80" oninput="updateSnortRule()" placeholder="any, 80, 443">
                        </div>

                        <div class="input-wrapper">
                            <label>Message</label>
                            <input type="text" id="ruleMsg" value="Suspicious traffic detected" oninput="updateSnortRule()" placeholder="Alert message">
                        </div>

                        <div class="input-wrapper">
                            <label>Content (optional)</label>
                            <input type="text" id="ruleContent" value="" oninput="updateSnortRule()" placeholder="/bin/sh, cmd.exe">
                        </div>

                        <div class="input-wrapper">
                            <label>SID</label>
                            <input type="text" id="ruleSid" value="1000001" oninput="updateSnortRule()" placeholder="Unique rule ID">
                        </div>
                    </div>

                    <h3>Generated Snort Rule</h3>
                    <div class="rule-output" id="snortRuleOutput">
                        alert tcp any any -> any 80 (msg:"Suspicious traffic detected"; sid:1000001; rev:1;)
                    </div>

                    <div class="warning-box">
                        <strong>Common Rule Options:</strong>
                        <ul>
                            <li><code>content:"string"</code> - Match specific payload content</li>
                            <li><code>flags:S</code> - Match TCP flags (S=SYN, A=ACK, F=FIN)</li>
                            <li><code>flow:to_server,established</code> - Match connection state</li>
                            <li><code>byte_test</code> - Test byte values</li>
                            <li><code>pcre:"/regex/"</code> - Perl-compatible regex matching</li>
                            <li><code>threshold:type limit, track by_src, count 5, seconds 60</code> - Rate limiting</li>
                        </ul>
                    </div>

                    <h3>Example Rules</h3>
                    <div class="code-block">
# Detect SQL injection attempts
alert tcp any any -> any 80 (msg:"SQL Injection Attempt"; content:"union"; nocase; content:"select"; nocase; sid:1000002;)

# Detect port scan (SYN scan)
alert tcp any any -> any any (msg:"Possible SYN Scan"; flags:S; threshold:type threshold, track by_src, count 20, seconds 10; sid:1000003;)

# Detect reverse shell
alert tcp any any -> any any (msg:"Reverse Shell Detected"; content:"/bin/sh"; flow:to_server,established; sid:1000004;)

# Detect Nmap version scan
alert tcp any any -> any any (msg:"Nmap Version Scan"; content:"|00|"; depth:1; flow:to_server; sid:1000005;)
                    </div>

                    <button class="btn" onclick="testSnortRule()">Test Rule Syntax</button>
                    <button class="btn btn-secondary" onclick="loadExampleRule()">Load Example</button>
                </div>

                <button class="btn" onclick="completeSection('snort', 12)">Complete Snort Training</button>
            </div>
        </div>

        <!-- Evasion Simulator Section -->
        <div id="evasion" class="content-section">
            <div class="card">
                <h2>IDS/IPS Evasion Technique Simulator</h2>

                <div class="technique-grid">
                    <div class="technique-card">
                        <h4>Packet Fragmentation</h4>
                        <p>Split attack payload across multiple small packets to evade signature matching. IDS may not reassemble fragments.</p>
                        <button class="btn" onclick="simulateEvasion('fragmentation')">Simulate</button>
                    </div>

                    <div class="technique-card">
                        <h4>Decoy Scanning</h4>
                        <p>Generate traffic from multiple spoofed source IPs to hide the real attacker among noise.</p>
                        <button class="btn" onclick="simulateEvasion('decoy')">Simulate</button>
                    </div>

                    <div class="technique-card">
                        <h4>Session Splicing</h4>
                        <p>Insert time delays between packets to avoid pattern matching within IDS timeout windows.</p>
                        <button class="btn" onclick="simulateEvasion('splicing')">Simulate</button>
                    </div>

                    <div class="technique-card">
                        <h4>Encoding (Unicode/Base64)</h4>
                        <p>Obfuscate payload using various encoding schemes that application decodes but IDS doesn't recognize.</p>
                        <button class="btn" onclick="simulateEvasion('encoding')">Simulate</button>
                    </div>

                    <div class="technique-card">
                        <h4>TTL Manipulation</h4>
                        <p>Send packets with TTL values that expire before reaching target but after IDS, causing insertion attacks.</p>
                        <button class="btn" onclick="simulateEvasion('ttl')">Simulate</button>
                    </div>

                    <div class="technique-card">
                        <h4>IDS DoS (Fail Open)</h4>
                        <p>Overwhelm IDS with traffic to cause resource exhaustion, forcing it to fail open and stop inspecting.</p>
                        <button class="btn" onclick="simulateEvasion('dos')">Simulate</button>
                    </div>
                </div>

                <div class="evasion-simulator">
                    <h3 id="evasionTitle">Select an Evasion Technique</h3>
                    <div class="packet-visualization" id="packetViz">
                        <div class="ids-detector" id="idsDetector">
                            <div>IDS</div>
                            <div style="font-size: 0.8em;">Status: Idle</div>
                        </div>
                    </div>
                    <div class="info-box" id="evasionExplanation">
                        Click a technique above to see the evasion simulation in action.
                    </div>
                </div>

                <div class="danger-box">
                    <strong>Mitigation Strategies:</strong>
                    <ul>
                        <li><strong>Fragment reassembly:</strong> Reconstruct packets before inspection</li>
                        <li><strong>Stream normalization:</strong> Standardize traffic before analysis</li>
                        <li><strong>Protocol validation:</strong> Enforce RFC compliance</li>
                        <li><strong>Anomaly detection:</strong> Baseline normal behavior, flag deviations</li>
                        <li><strong>Multiple detection layers:</strong> Network + host-based + behavioral</li>
                        <li><strong>Regular updates:</strong> Keep signatures and rules current</li>
                        <li><strong>Proper tuning:</strong> Reduce false positives/negatives</li>
                    </ul>
                </div>

                <button class="btn" onclick="completeSection('evasion', 15)">Complete Evasion Training</button>
            </div>
        </div>

        <!-- Alert Classification Section -->
        <div id="alerts" class="content-section">
            <div class="card">
                <h2>Alert Classification Exercise</h2>
                <p>Classify each scenario as TP, FP, TN, or FN</p>

                <div class="alert-grid" id="alertGrid">
                    <!-- Generated by JavaScript -->
                </div>

                <div class="quiz-results" id="alertResults" style="display: none;">
                    <h2>Results</h2>
                    <p id="alertScore"></p>
                </div>

                <button class="btn" onclick="checkAlertClassifications()">Check Answers</button>
                <button class="btn btn-secondary" onclick="resetAlerts()">Reset</button>
            </div>
        </div>

        <!-- TTL Attack Section -->
        <div id="ttl" class="content-section">
            <div class="card">
                <h2>TTL Manipulation Attack Simulator</h2>

                <div class="info-box">
                    <strong>TTL Attack Principle:</strong> By crafting packets with specific TTL values, an attacker can send packets that the IDS sees but the target doesn't (insertion), or that the target sees but the IDS doesn't (evasion).
                </div>

                <div class="ttl-animator">
                    <h3>Network Topology</h3>
                    <div class="ttl-network" id="ttlNetwork">
                        <div class="ttl-hop" style="left: 50px; top: 100px;" id="hop1">
                            <div>Attacker</div>
                            <div>üñ•Ô∏è</div>
                        </div>

                        <div class="ttl-hop" style="left: 200px; top: 100px;" id="hop2">
                            <div>Router 1</div>
                            <div>TTL--</div>
                        </div>

                        <div class="ttl-hop" style="left: 350px; top: 100px;" id="hop3">
                            <div>IDS</div>
                            <div>üîç</div>
                        </div>

                        <div class="ttl-hop" style="left: 500px; top: 100px;" id="hop4">
                            <div>Router 2</div>
                            <div>TTL--</div>
                        </div>

                        <div class="ttl-hop" style="left: 650px; top: 100px;" id="hop5">
                            <div>Target</div>
                            <div>üéØ</div>
                        </div>
                    </div>

                    <div class="rule-input-group">
                        <div class="input-wrapper">
                            <label>Attack Type</label>
                            <select id="ttlAttackType">
                                <option value="insertion">Insertion Attack (IDS sees, target doesn't)</option>
                                <option value="evasion">Evasion Attack (Target sees, IDS doesn't)</option>
                            </select>
                        </div>

                        <div class="input-wrapper">
                            <label>Packet TTL</label>
                            <input type="number" id="ttlValue" value="3" min="1" max="5">
                        </div>
                    </div>

                    <button class="btn" onclick="animateTTLAttack()">Launch TTL Attack</button>
                    <button class="btn btn-secondary" onclick="resetTTL()">Reset</button>

                    <div class="warning-box" id="ttlExplanation">
                        <strong>How it works:</strong>
                        <ul>
                            <li><strong>Insertion:</strong> Send packet with TTL=3. IDS at hop 3 sees it, but packet expires before reaching target at hop 5. IDS may false positive on benign follow-up traffic.</li>
                            <li><strong>Evasion:</strong> Send malicious packet fragments with varying TTLs. Some expire at IDS, others reach target. Target reassembles attack, IDS sees incomplete benign data.</li>
                            <li><strong>Defense:</strong> IDS should match exact network topology and TTL decrements, normalize streams</li>
                        </ul>
                    </div>
                </div>

                <button class="btn" onclick="completeSection('ttl', 10)">Complete TTL Training</button>
            </div>
        </div>

        <!-- Firewall Analyzer Section -->
        <div id="firewall" class="content-section">
            <div class="card">
                <h2>Firewall Rule Analyzer</h2>
                <p>Analyze firewall rules for security issues and optimization opportunities</p>

                <div class="rule-analyzer">
                    <h3>Enter Firewall Rules (iptables format)</h3>
                    <textarea class="rule-input" id="firewallRules" placeholder="Enter iptables rules, one per line...
Example:
-A INPUT -p tcp --dport 22 -j ACCEPT
-A INPUT -p tcp --dport 80 -j ACCEPT
-A INPUT -j DROP">-A INPUT -p tcp --dport 22 -s 192.168.1.0/24 -j ACCEPT
-A INPUT -p tcp --dport 80 -j ACCEPT
-A INPUT -p tcp --dport 443 -j ACCEPT
-A INPUT -p icmp -j ACCEPT
-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
-A INPUT -j DROP</textarea>

                    <button class="btn" onclick="analyzeFirewallRules()">Analyze Rules</button>
                    <button class="btn btn-secondary" onclick="loadFirewallExample()">Load Example</button>

                    <div class="rule-analysis" id="firewallAnalysis">
                        <p style="color: var(--text-secondary);">Analysis will appear here...</p>
                    </div>
                </div>

                <div class="technique-grid">
                    <div class="technique-card">
                        <h4>Rule Order Matters</h4>
                        <p>Firewalls process rules top-to-bottom. Most specific rules should come first. A broad ACCEPT before specific DROPs makes drops ineffective.</p>
                    </div>

                    <div class="technique-card">
                        <h4>Default Deny</h4>
                        <p>Always end with a default DROP/REJECT rule. Whitelist approach is more secure than blacklist.</p>
                    </div>

                    <div class="technique-card">
                        <h4>State Tracking</h4>
                        <p>Use stateful rules (ESTABLISHED,RELATED) to allow return traffic without opening unnecessary inbound ports.</p>
                    </div>

                    <div class="technique-card">
                        <h4>Logging</h4>
                        <p>Log dropped packets for forensics and tuning, but rate-limit to prevent log flooding DoS.</p>
                    </div>
                </div>

                <button class="btn" onclick="completeSection('firewall', 10)">Complete Firewall Training</button>
            </div>
        </div>

        <!-- Quiz Section -->
        <div id="quiz" class="content-section">
            <div class="card">
                <h2>Final Assessment Quiz</h2>
                <p>Test your knowledge of IDS/IPS and evasion techniques (12 questions)</p>

                <div class="quiz-container" id="quizContainer">
                    <!-- Generated by JavaScript -->
                </div>

                <button class="btn" onclick="submitQuiz()">Submit Quiz</button>
                <button class="btn btn-secondary" onclick="resetQuiz()">Reset Quiz</button>

                <div class="quiz-results" id="quizResults" style="display: none;">
                    <h2>Quiz Complete!</h2>
                    <p id="quizScore"></p>
                    <p id="quizFeedback"></p>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>Vault Navigation</h2>
            <p>Return to the Dark Arts vault to continue your training</p>
            <button class="btn" onclick="window.location.href='../index.html'">Return to Dark Arts Vault</button>
        </div>
    </div>

    <script>
        // Progress tracking
        let progress = {
            theory: false,
            network: false,
            snort: false,
            evasion: false,
            alerts: false,
            ttl: false,
            firewall: false,
            quiz: false
        };
        let totalXP = 0;
        const maxXP = 75;

        // Tab switching
        function switchTab(tabName) {
            document.querySelectorAll('.content-section').forEach(section => {
                section.classList.remove('active');
            });
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });

            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
        }

        // Complete section
        function completeSection(section, xp) {
            if (!progress[section]) {
                progress[section] = true;
                totalXP += xp;
                updateProgress();

                alert(`Section completed! +${xp} XP earned`);
            } else {
                alert('Section already completed!');
            }
        }

        // Update progress bar
        function updateProgress() {
            const percentage = (totalXP / maxXP) * 100;
            document.getElementById('progressFill').style.width = percentage + '%';
            document.getElementById('progressFill').textContent = Math.round(percentage) + '%';
            document.getElementById('xpDisplay').textContent = `${totalXP} / ${maxXP} XP`;

            if (totalXP >= maxXP) {
                setTimeout(() => {
                    alert('üéâ Congratulations! You have mastered IDS/IPS Evasion! All 75 XP earned!');
                }, 500);
            }
        }

        // Network Diagram
        const nodeDescriptions = [
            "Internet: External untrusted network. All traffic originates here for inbound connections.",
            "Perimeter Firewall: First line of defense. Filters traffic based on IP, port, and protocol rules.",
            "NIDS #1 (External): Monitors traffic BEFORE firewall processing. Detects attacks that may be blocked. Out-of-band monitoring via SPAN port.",
            "DMZ: Demilitarized zone hosting public-facing servers (web, email, DNS). Isolated from internal network.",
            "Internal Firewall: Second firewall protecting internal LAN. Implements stricter rules for corporate resources.",
            "NIPS #2 (Inline): Inline prevention system that can DROP malicious packets. Actively protects internal network but can introduce latency.",
            "Internal LAN: Corporate network with workstations, servers, and sensitive data. Final protection zone.",
            "HIDS: Host-based IDS on critical servers. Monitors local logs, file integrity, and system calls. Sees traffic after decryption.",
            "Honeypot: Decoy system in DMZ to attract and detect attackers. Generates high-fidelity alerts when accessed."
        ];

        let activeNode = -1;

        function highlightNode(nodeId) {
            // Remove previous active states
            document.querySelectorAll('.network-node').forEach(n => n.classList.remove('active'));

            // Activate selected node
            document.getElementById('node' + nodeId).classList.add('active');

            // Update info box
            document.getElementById('nodeInfo').innerHTML = `<strong>Selected:</strong> ${nodeDescriptions[nodeId]}`;

            activeNode = nodeId;
        }

        // Snort Rule Builder
        function updateSnortRule() {
            const action = document.getElementById('ruleAction').value;
            const protocol = document.getElementById('ruleProtocol').value;
            const srcIp = document.getElementById('ruleSrcIp').value || 'any';
            const srcPort = document.getElementById('ruleSrcPort').value || 'any';
            const direction = document.getElementById('ruleDirection').value;
            const dstIp = document.getElementById('ruleDstIp').value || 'any';
            const dstPort = document.getElementById('ruleDstPort').value || 'any';
            const msg = document.getElementById('ruleMsg').value || 'Alert';
            const content = document.getElementById('ruleContent').value;
            const sid = document.getElementById('ruleSid').value || '1000001';

            let rule = `${action} ${protocol} ${srcIp} ${srcPort} ${direction} ${dstIp} ${dstPort} (`;
            rule += `msg:"${msg}"; `;

            if (content) {
                rule += `content:"${content}"; `;
            }

            rule += `sid:${sid}; rev:1;)`;

            document.getElementById('snortRuleOutput').textContent = rule;
        }

        function testSnortRule() {
            const rule = document.getElementById('snortRuleOutput').textContent;

            // Basic syntax validation
            if (rule.includes('msg:') && rule.includes('sid:') && rule.includes(';)')) {
                alert('‚úì Rule syntax appears valid!\n\nTo deploy:\n1. Save to /etc/snort/rules/local.rules\n2. Include in snort.conf\n3. Test: snort -T -c /etc/snort/snort.conf\n4. Run: snort -A console -c /etc/snort/snort.conf -i eth0');
            } else {
                alert('‚úó Rule syntax error detected. Check your rule structure.');
            }
        }

        function loadExampleRule() {
            document.getElementById('ruleAction').value = 'alert';
            document.getElementById('ruleProtocol').value = 'tcp';
            document.getElementById('ruleSrcIp').value = 'any';
            document.getElementById('ruleSrcPort').value = 'any';
            document.getElementById('ruleDirection').value = '->';
            document.getElementById('ruleDstIp').value = '$HOME_NET';
            document.getElementById('ruleDstPort').value = '80';
            document.getElementById('ruleMsg').value = 'SQL Injection Attempt Detected';
            document.getElementById('ruleContent').value = 'union select';
            document.getElementById('ruleSid').value = '1000042';
            updateSnortRule();
        }

        // Initialize Snort rule
        updateSnortRule();

        // Evasion Simulator
        let evasionAnimation = null;

        function simulateEvasion(technique) {
            // Clear previous animation
            if (evasionAnimation) {
                clearInterval(evasionAnimation);
            }

            const viz = document.getElementById('packetViz');
            const ids = document.getElementById('idsDetector');
            const title = document.getElementById('evasionTitle');
            const explanation = document.getElementById('evasionExplanation');

            // Clear existing packets
            document.querySelectorAll('.packet').forEach(p => p.remove());
            ids.classList.remove('alerted');
            ids.innerHTML = '<div>IDS</div><div style="font-size: 0.8em;">Status: Monitoring</div>';

            switch(technique) {
                case 'fragmentation':
                    title.textContent = 'Packet Fragmentation Evasion';
                    explanation.innerHTML = '<strong>Technique:</strong> Attack payload "ATTACK" split into tiny fragments: [AT] [TA] [CK]. IDS signature looks for complete "ATTACK" string but never sees it assembled.<br><br><strong>Command:</strong> <code>nmap -f target</code> (fragment packets)<br><strong>Tool:</strong> Fragroute, Scapy';

                    let fragPos = 0;
                    const fragments = ['AT', 'TA', 'CK'];
                    evasionAnimation = setInterval(() => {
                        if (fragPos < fragments.length) {
                            const packet = document.createElement('div');
                            packet.className = 'packet fragmented';
                            packet.textContent = fragments[fragPos];
                            packet.style.left = '20px';
                            packet.style.top = (80 + fragPos * 30) + 'px';
                            viz.appendChild(packet);

                            setTimeout(() => {
                                packet.style.left = viz.offsetWidth - 120 + 'px';
                            }, 50);

                            fragPos++;
                        } else {
                            clearInterval(evasionAnimation);
                            ids.innerHTML = '<div>IDS</div><div style="font-size: 0.8em; color: #10b981;">No Match</div>';
                        }
                    }, 800);
                    break;

                case 'decoy':
                    title.textContent = 'Decoy Scanning';
                    explanation.innerHTML = '<strong>Technique:</strong> Real scan hidden among 5 spoofed source IPs. IDS sees traffic from multiple sources, real attacker blends in.<br><br><strong>Command:</strong> <code>nmap -D RND:5 target</code><br><strong>Defense:</strong> Correlation analysis, TTL fingerprinting';

                    for (let i = 0; i < 6; i++) {
                        setTimeout(() => {
                            const packet = document.createElement('div');
                            packet.className = i === 3 ? 'packet' : 'packet decoy';
                            packet.textContent = i === 3 ? 'REAL' : 'DECOY';
                            packet.style.left = '20px';
                            packet.style.top = (60 + i * 25) + 'px';
                            viz.appendChild(packet);

                            setTimeout(() => {
                                packet.style.left = viz.offsetWidth - 120 + 'px';
                            }, 50);

                            if (i === 5) {
                                setTimeout(() => {
                                    ids.classList.add('alerted');
                                    ids.innerHTML = '<div>IDS</div><div style="font-size: 0.8em; color: #dc2626;">Alert: Scan?</div>';
                                }, 1000);
                            }
                        }, i * 400);
                    }
                    break;

                case 'splicing':
                    title.textContent = 'Session Splicing';
                    explanation.innerHTML = '<strong>Technique:</strong> Insert delays between packets (e.g., 500ms). IDS timeout window may expire before seeing complete attack signature.<br><br><strong>Tool:</strong> Nikto with --evasion 4<br><strong>Defense:</strong> Longer session timeout, stateful reassembly';

                    let spliceCount = 0;
                    const splicePackets = ['A', 'T', 'T', 'A', 'C', 'K'];
                    evasionAnimation = setInterval(() => {
                        if (spliceCount < splicePackets.length) {
                            const packet = document.createElement('div');
                            packet.className = 'packet';
                            packet.textContent = splicePackets[spliceCount];
                            packet.style.left = '20px';
                            packet.style.top = '100px';
                            viz.appendChild(packet);

                            setTimeout(() => {
                                packet.style.left = viz.offsetWidth - 120 + 'px';
                            }, 50);

                            spliceCount++;

                            if (spliceCount === 3) {
                                ids.innerHTML = '<div>IDS</div><div style="font-size: 0.8em; color: #f59e0b;">Session timeout</div>';
                            }
                        } else {
                            clearInterval(evasionAnimation);
                            ids.innerHTML = '<div>IDS</div><div style="font-size: 0.8em; color: #10b981;">No Match</div>';
                        }
                    }, 1200);
                    break;

                case 'encoding':
                    title.textContent = 'Unicode/Base64 Encoding';
                    explanation.innerHTML = '<strong>Technique:</strong> Encode payload as %75%6E%69%6F%6E (unicode) or dW5pb24= (base64). Web server decodes it, but IDS signature looks for literal "union".<br><br><strong>Example:</strong> SELECT becomes %53%45%4C%45%43%54<br><strong>Defense:</strong> Normalize and decode before inspection';

                    const encodedPacket = document.createElement('div');
                    encodedPacket.className = 'packet';
                    encodedPacket.textContent = '%41%54%54';
                    encodedPacket.style.left = '20px';
                    encodedPacket.style.top = '100px';
                    viz.appendChild(encodedPacket);

                    setTimeout(() => {
                        encodedPacket.style.left = viz.offsetWidth - 120 + 'px';
                    }, 50);

                    setTimeout(() => {
                        ids.innerHTML = '<div>IDS</div><div style="font-size: 0.8em; color: #10b981;">No Match</div>';
                        encodedPacket.textContent = 'ATT';
                        encodedPacket.style.backgroundColor = '#10b981';
                    }, 1500);
                    break;

                case 'ttl':
                    title.textContent = 'TTL Manipulation';
                    explanation.innerHTML = '<strong>Technique:</strong> Send garbage with TTL=2 (expires at IDS). Then send real attack with TTL=5 (reaches target). IDS sees garbage + attack = nonsense.<br><br><strong>Tool:</strong> Nmap --ttl<br><strong>Defense:</strong> Match IDS topology to actual network';

                    const garbagePacket = document.createElement('div');
                    garbagePacket.className = 'packet decoy';
                    garbagePacket.textContent = 'JUNK';
                    garbagePacket.style.left = '20px';
                    garbagePacket.style.top = '80px';
                    viz.appendChild(garbagePacket);

                    setTimeout(() => {
                        garbagePacket.style.left = '400px';
                    }, 50);

                    setTimeout(() => {
                        garbagePacket.style.opacity = '0';
                        ids.innerHTML = '<div>IDS</div><div style="font-size: 0.8em;">Saw: JUNK</div>';
                    }, 800);

                    setTimeout(() => {
                        const realPacket = document.createElement('div');
                        realPacket.className = 'packet';
                        realPacket.textContent = 'ATTACK';
                        realPacket.style.left = '20px';
                        realPacket.style.top = '120px';
                        viz.appendChild(realPacket);

                        setTimeout(() => {
                            realPacket.style.left = viz.offsetWidth - 120 + 'px';
                        }, 50);

                        setTimeout(() => {
                            ids.innerHTML = '<div>IDS</div><div style="font-size: 0.8em; color: #10b981;">Confused</div>';
                        }, 800);
                    }, 1500);
                    break;

                case 'dos':
                    title.textContent = 'IDS Denial of Service';
                    explanation.innerHTML = '<strong>Technique:</strong> Flood IDS with high volume traffic to exhaust CPU/memory. IDS may fail-open (stop inspecting) to maintain availability.<br><br><strong>Attack:</strong> Generate 100K packets/sec<br><strong>Defense:</strong> Fail-closed policy, rate limiting, dedicated hardware';

                    let dosCount = 0;
                    evasionAnimation = setInterval(() => {
                        if (dosCount < 20) {
                            for (let i = 0; i < 3; i++) {
                                const packet = document.createElement('div');
                                packet.className = 'packet decoy';
                                packet.textContent = 'FLOOD';
                                packet.style.left = '20px';
                                packet.style.top = (60 + Math.random() * 120) + 'px';
                                packet.style.fontSize = '0.6em';
                                viz.appendChild(packet);

                                setTimeout(() => {
                                    packet.style.left = viz.offsetWidth - 120 + 'px';
                                    packet.style.opacity = '0.3';
                                }, 50);
                            }
                            dosCount++;

                            if (dosCount === 10) {
                                ids.classList.add('alerted');
                                ids.innerHTML = '<div>IDS</div><div style="font-size: 0.7em; color: #dc2626;">CPU: 99%</div>';
                            }

                            if (dosCount === 15) {
                                ids.innerHTML = '<div>IDS</div><div style="font-size: 0.7em; color: #f59e0b;">FAIL OPEN</div>';
                            }
                        } else {
                            clearInterval(evasionAnimation);
                        }
                    }, 200);
                    break;
            }
        }

        // Alert Classification Exercise
        const alertScenarios = [
            {
                scenario: "IDS alerts on SSH brute force attempt. Logs confirm 500 failed login attempts from 203.0.113.5 in 60 seconds.",
                correct: "TP",
                explanation: "True Positive - Attack occurred and was detected"
            },
            {
                scenario: "IDS alerts on SQL injection. Investigation shows legitimate query: SELECT * FROM users WHERE id=1",
                correct: "FP",
                explanation: "False Positive - No attack, but IDS alerted"
            },
            {
                scenario: "Normal HTTP traffic flows. No alerts generated. No attacks in progress.",
                correct: "TN",
                explanation: "True Negative - No attack, no alert (correct)"
            },
            {
                scenario: "Attacker successfully exploits unpatched SMB vulnerability. No IDS alerts generated. Shells established.",
                correct: "FN",
                explanation: "False Negative - Attack succeeded but IDS missed it (worst case)"
            },
            {
                scenario: "IDS alerts on port scan. Nmap SYN scan detected from 198.51.100.25.",
                correct: "TP",
                explanation: "True Positive - Reconnaissance attack detected"
            },
            {
                scenario: "IDS alerts on 'malicious payload' in HTTP traffic. Turns out to be encoded image data.",
                correct: "FP",
                explanation: "False Positive - Benign traffic misidentified"
            },
            {
                scenario: "Routine business traffic between approved systems. No alerts. No malicious activity.",
                correct: "TN",
                explanation: "True Negative - Normal operation"
            },
            {
                scenario: "Attackers use fragmented packets to bypass IDS. Web server compromised. No alerts.",
                correct: "FN",
                explanation: "False Negative - Evasion technique succeeded"
            }
        ];

        let alertAnswers = {};

        function initAlertExercise() {
            const grid = document.getElementById('alertGrid');
            grid.innerHTML = '';
            alertAnswers = {};

            alertScenarios.forEach((item, index) => {
                const card = document.createElement('div');
                card.className = 'alert-card';
                card.innerHTML = `
                    <p style="margin-bottom: 10px;"><strong>Scenario ${index + 1}:</strong> ${item.scenario}</p>
                    <div class="classification-buttons">
                        <button class="classify-btn" onclick="selectClassification(${index}, 'TP')">True Positive</button>
                        <button class="classify-btn" onclick="selectClassification(${index}, 'FP')">False Positive</button>
                        <button class="classify-btn" onclick="selectClassification(${index}, 'TN')">True Negative</button>
                        <button class="classify-btn" onclick="selectClassification(${index}, 'FN')">False Negative</button>
                    </div>
                    <div id="alert-explanation-${index}" style="margin-top: 10px; font-size: 0.9em; color: var(--text-secondary); display: none;"></div>
                `;
                grid.appendChild(card);
            });
        }

        function selectClassification(scenarioIndex, classification) {
            alertAnswers[scenarioIndex] = classification;

            // Visual feedback
            const card = document.querySelectorAll('.alert-card')[scenarioIndex];
            const buttons = card.querySelectorAll('.classify-btn');
            buttons.forEach(btn => {
                btn.style.background = 'var(--bg-secondary)';
                btn.style.borderColor = 'var(--border)';
            });

            const selectedBtn = Array.from(buttons).find(btn => btn.textContent === classification.replace('TP', 'True Positive').replace('FP', 'False Positive').replace('TN', 'True Negative').replace('FN', 'False Negative'));
            if (selectedBtn) {
                selectedBtn.style.background = 'var(--primary)';
                selectedBtn.style.borderColor = 'var(--primary)';
            }
        }

        function checkAlertClassifications() {
            let correct = 0;

            alertScenarios.forEach((item, index) => {
                const card = document.querySelectorAll('.alert-card')[index];
                const explanation = document.getElementById(`alert-explanation-${index}`);

                if (alertAnswers[index] === item.correct) {
                    card.classList.add('correct');
                    card.classList.remove('incorrect');
                    correct++;
                    explanation.innerHTML = `‚úì Correct! ${item.explanation}`;
                    explanation.style.color = 'var(--success)';
                } else {
                    card.classList.add('incorrect');
                    card.classList.remove('correct');
                    explanation.innerHTML = `‚úó Incorrect. Correct answer: ${item.correct}. ${item.explanation}`;
                    explanation.style.color = 'var(--accent)';
                }
                explanation.style.display = 'block';
            });

            const results = document.getElementById('alertResults');
            const score = document.getElementById('alertScore');
            results.style.display = 'block';
            score.textContent = `You got ${correct} out of ${alertScenarios.length} correct!`;

            if (correct === alertScenarios.length) {
                completeSection('alerts', 10);
            } else if (correct >= alertScenarios.length * 0.75) {
                alert(`Good work! Score: ${correct}/${alertScenarios.length}. Review the explanations and try again for full XP.`);
            }
        }

        function resetAlerts() {
            initAlertExercise();
            document.getElementById('alertResults').style.display = 'none';
        }

        // Initialize alert exercise
        initAlertExercise();

        // TTL Attack Animator
        let ttlAnimationRunning = false;

        function animateTTLAttack() {
            if (ttlAnimationRunning) return;

            const attackType = document.getElementById('ttlAttackType').value;
            const ttlValue = parseInt(document.getElementById('ttlValue').value);

            // Clear previous packets
            document.querySelectorAll('.ttl-packet').forEach(p => p.remove());

            const packet = document.createElement('div');
            packet.className = 'ttl-packet';
            packet.textContent = `TTL=${ttlValue}`;
            packet.style.left = '50px';
            packet.style.top = '100px';
            document.getElementById('ttlNetwork').appendChild(packet);

            ttlAnimationRunning = true;
            let currentHop = 1;
            let currentTTL = ttlValue;

            const hopPositions = [50, 200, 350, 500, 650];

            const animationInterval = setInterval(() => {
                if (currentHop < 5) {
                    currentHop++;
                    currentTTL--;

                    packet.style.left = hopPositions[currentHop] + 'px';
                    packet.textContent = `TTL=${currentTTL}`;

                    if (currentTTL === 0) {
                        packet.style.backgroundColor = 'var(--text-secondary)';
                        packet.textContent = 'EXPIRED';

                        if (attackType === 'insertion' && currentHop === 3) {
                            // IDS sees packet, target doesn't
                            setTimeout(() => {
                                alert('Insertion Attack: IDS at hop 3 saw the packet, but it expired before reaching target. IDS may misinterpret future traffic based on this phantom packet.');
                                ttlAnimationRunning = false;
                            }, 500);
                        } else {
                            setTimeout(() => {
                                alert(`Packet expired at hop ${currentHop}. ${currentHop < 5 ? 'Did not reach target.' : 'Reached target.'}`);
                                ttlAnimationRunning = false;
                            }, 500);
                        }

                        clearInterval(animationInterval);
                    } else if (currentHop === 5) {
                        packet.style.backgroundColor = 'var(--success)';
                        setTimeout(() => {
                            if (attackType === 'evasion') {
                                alert('Evasion scenario: This packet (or reassembled fragments) reached target but IDS saw different data due to TTL-manipulated injection packets.');
                            } else {
                                alert('Packet successfully reached target.');
                            }
                            ttlAnimationRunning = false;
                        }, 500);
                        clearInterval(animationInterval);
                    }
                } else {
                    clearInterval(animationInterval);
                    ttlAnimationRunning = false;
                }
            }, 1000);
        }

        function resetTTL() {
            document.querySelectorAll('.ttl-packet').forEach(p => p.remove());
            ttlAnimationRunning = false;
        }

        // Firewall Rule Analyzer
        function analyzeFirewallRules() {
            const rules = document.getElementById('firewallRules').value.split('\n').filter(r => r.trim());
            const analysis = document.getElementById('firewallAnalysis');

            let findings = [];
            let hasDefaultDeny = false;
            let hasStateTracking = false;
            let hasLogging = false;
            let ruleCount = 0;

            rules.forEach((rule, index) => {
                ruleCount++;

                // Check for default deny
                if (rule.includes('-j DROP') || rule.includes('-j REJECT')) {
                    if (index === rules.length - 1) {
                        hasDefaultDeny = true;
                        findings.push({
                            type: 'success',
                            message: `Rule ${index + 1}: Default deny policy detected (good security practice)`
                        });
                    }
                }

                // Check for state tracking
                if (rule.includes('ESTABLISHED') || rule.includes('RELATED')) {
                    hasStateTracking = true;
                    findings.push({
                        type: 'success',
                        message: `Rule ${index + 1}: Stateful tracking enabled (allows return traffic)`
                    });
                }

                // Check for logging
                if (rule.includes('LOG')) {
                    hasLogging = true;
                    findings.push({
                        type: 'info',
                        message: `Rule ${index + 1}: Logging enabled (good for forensics)`
                    });
                }

                // Check for overly permissive rules
                if (rule.includes('any') && rule.includes('ACCEPT') && !rule.includes('ESTABLISHED')) {
                    if (index < rules.length - 1) {
                        findings.push({
                            type: 'warning',
                            message: `Rule ${index + 1}: Broad ACCEPT rule - ensure this is necessary`
                        });
                    }
                }

                // Check for SSH access restriction
                if (rule.includes('--dport 22') && rule.includes('ACCEPT')) {
                    if (rule.includes('-s ')) {
                        findings.push({
                            type: 'success',
                            message: `Rule ${index + 1}: SSH access restricted to specific source (good)`
                        });
                    } else {
                        findings.push({
                            type: 'danger',
                            message: `Rule ${index + 1}: SSH open to all sources - restrict with -s option`
                        });
                    }
                }
            });

            // Summary findings
            if (!hasDefaultDeny) {
                findings.push({
                    type: 'danger',
                    message: 'Missing default deny rule at end of chain - all unmatched traffic will be accepted!'
                });
            }

            if (!hasStateTracking) {
                findings.push({
                    type: 'warning',
                    message: 'No stateful tracking detected - consider adding rule for ESTABLISHED,RELATED connections'
                });
            }

            // Build HTML output
            let html = `<h3 style="color: var(--primary); margin-bottom: 15px;">Analysis Results</h3>`;
            html += `<p><strong>Total Rules:</strong> ${ruleCount}</p>`;

            findings.forEach(finding => {
                const colors = {
                    success: 'var(--success)',
                    info: 'var(--info)',
                    warning: 'var(--warning)',
                    danger: 'var(--accent)'
                };

                html += `<div class="analysis-item" style="border-left-color: ${colors[finding.type]};">`;
                html += finding.message;
                html += `</div>`;
            });

            html += `<div style="margin-top: 20px; padding: 15px; background: var(--bg-tertiary); border-radius: 5px;">`;
            html += `<strong>Security Score:</strong> `;

            let score = 0;
            if (hasDefaultDeny) score += 40;
            if (hasStateTracking) score += 30;
            if (hasLogging) score += 15;
            if (findings.filter(f => f.type === 'danger').length === 1) score += 15; // Only default deny warning

            const scoreColor = score >= 80 ? 'var(--success)' : score >= 60 ? 'var(--warning)' : 'var(--accent)';
            html += `<span style="color: ${scoreColor}; font-size: 1.5em; font-weight: bold;">${score}/100</span>`;
            html += `</div>`;

            analysis.innerHTML = html;
        }

        function loadFirewallExample() {
            document.getElementById('firewallRules').value = `-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
-A INPUT -p tcp --dport 22 -s 10.0.0.0/8 -j ACCEPT
-A INPUT -p tcp --dport 80 -j ACCEPT
-A INPUT -p tcp --dport 443 -j ACCEPT
-A INPUT -p icmp --icmp-type echo-request -m limit --limit 5/sec -j ACCEPT
-A INPUT -j LOG --log-prefix "FIREWALL-DROPPED: " --log-level 4
-A INPUT -j DROP`;
        }

        // Quiz System
        const quizQuestions = [
            {
                question: "What is the PRIMARY difference between IDS and IPS?",
                options: [
                    "IDS is software, IPS is hardware",
                    "IDS detects and alerts, IPS detects and prevents",
                    "IDS is faster than IPS",
                    "IDS works at Layer 2, IPS at Layer 3"
                ],
                correct: 1,
                explanation: "IPS is inline and can actively block traffic, while IDS only monitors and alerts."
            },
            {
                question: "Which alert type represents the MOST dangerous scenario?",
                options: [
                    "True Positive",
                    "False Positive",
                    "True Negative",
                    "False Negative"
                ],
                correct: 3,
                explanation: "False Negative means an attack occurred but IDS missed it - attacker succeeds undetected."
            },
            {
                question: "In a Snort rule, what does the '->' direction operator indicate?",
                options: [
                    "Bidirectional traffic",
                    "Traffic from source to destination only",
                    "Reverse traffic flow",
                    "Load balancing"
                ],
                correct: 1,
                explanation: "'->' means traffic flows from source to destination. '<>' would be bidirectional."
            },
            {
                question: "Which evasion technique splits attack payloads across multiple packets?",
                options: [
                    "Session splicing",
                    "Packet fragmentation",
                    "Unicode encoding",
                    "TTL manipulation"
                ],
                correct: 1,
                explanation: "Packet fragmentation breaks payloads into small chunks that IDS may not reassemble."
            },
            {
                question: "What does 'nmap -D RND:5' do?",
                options: [
                    "Scans 5 random ports",
                    "Uses 5 decoy source IPs",
                    "Delays packets by 5 seconds",
                    "Fragments into 5 pieces"
                ],
                correct: 1,
                explanation: "'-D RND:5' generates 5 random decoy source IPs to hide the real scanner."
            },
            {
                question: "In a TTL insertion attack, what happens?",
                options: [
                    "IDS sees packet that expires before reaching target",
                    "Target sees packet that IDS missed",
                    "Packets are encrypted",
                    "Firewall rules are modified"
                ],
                correct: 0,
                explanation: "Insertion attack: IDS sees packet with low TTL, but it expires before reaching target."
            },
            {
                question: "Which firewall type can inspect application-layer protocols like HTTP?",
                options: [
                    "Packet filtering firewall",
                    "Stateful inspection firewall",
                    "Application layer firewall",
                    "Circuit-level gateway"
                ],
                correct: 2,
                explanation: "Application layer firewalls perform deep packet inspection and understand protocols."
            },
            {
                question: "What is the purpose of a honeypot?",
                options: [
                    "Speed up network traffic",
                    "Attract and detect attackers",
                    "Encrypt sensitive data",
                    "Load balance servers"
                ],
                correct: 1,
                explanation: "Honeypots are decoy systems designed to attract attackers and detect intrusions."
            },
            {
                question: "Where should an NIDS be placed to monitor external attacks before filtering?",
                options: [
                    "Inside the internal LAN",
                    "Between firewall and internal network",
                    "Between Internet and perimeter firewall",
                    "On individual hosts"
                ],
                correct: 2,
                explanation: "Placing NIDS before the firewall lets you see all attacks, including those that will be blocked."
            },
            {
                question: "What does 'session splicing' evasion do?",
                options: [
                    "Fragments packets",
                    "Inserts time delays between packets",
                    "Encrypts traffic",
                    "Changes source IP"
                ],
                correct: 1,
                explanation: "Session splicing adds delays to evade IDS timeout windows and signature matching."
            },
            {
                question: "In iptables, which rule action would be safest for default policy?",
                options: [
                    "ACCEPT",
                    "LOG",
                    "DROP",
                    "REJECT"
                ],
                correct: 2,
                explanation: "Default DROP creates whitelist approach - only explicitly allowed traffic passes (most secure)."
            },
            {
                question: "What is the advantage of HIDS over NIDS?",
                options: [
                    "Protects entire network segment",
                    "Can see traffic after decryption",
                    "Faster performance",
                    "No installation required"
                ],
                correct: 1,
                explanation: "HIDS runs on the host and sees decrypted traffic, while NIDS may only see encrypted packets."
            }
        ];

        let quizAnswers = {};

        function initQuiz() {
            const container = document.getElementById('quizContainer');
            container.innerHTML = '';
            quizAnswers = {};

            quizQuestions.forEach((q, qIndex) => {
                const questionDiv = document.createElement('div');
                questionDiv.className = 'question';

                let html = `<h3>Question ${qIndex + 1}</h3><p>${q.question}</p><div class="options">`;

                q.options.forEach((option, oIndex) => {
                    html += `
                        <div class="option" onclick="selectQuizAnswer(${qIndex}, ${oIndex})">
                            <input type="radio" name="q${qIndex}" id="q${qIndex}_${oIndex}" style="margin-right: 10px;">
                            <label for="q${qIndex}_${oIndex}" style="cursor: pointer;">${option}</label>
                        </div>
                    `;
                });

                html += `</div><div id="quiz-explanation-${qIndex}" style="margin-top: 10px; display: none;"></div>`;
                questionDiv.innerHTML = html;
                container.appendChild(questionDiv);
            });
        }

        function selectQuizAnswer(questionIndex, optionIndex) {
            quizAnswers[questionIndex] = optionIndex;

            // Update radio button
            const radio = document.getElementById(`q${questionIndex}_${optionIndex}`);
            radio.checked = true;

            // Visual feedback
            const options = document.querySelectorAll(`input[name="q${questionIndex}"]`);
            options.forEach(opt => {
                opt.parentElement.classList.remove('selected');
            });
            radio.parentElement.classList.add('selected');
        }

        function submitQuiz() {
            let correct = 0;

            quizQuestions.forEach((q, index) => {
                const explanation = document.getElementById(`quiz-explanation-${index}`);
                const options = document.querySelectorAll(`input[name="q${index}"]`);

                if (quizAnswers[index] === q.correct) {
                    correct++;
                    options[quizAnswers[index]].parentElement.classList.add('correct');
                    explanation.innerHTML = `<span style="color: var(--success);">‚úì Correct!</span> ${q.explanation}`;
                } else {
                    if (quizAnswers[index] !== undefined) {
                        options[quizAnswers[index]].parentElement.classList.add('incorrect');
                    }
                    options[q.correct].parentElement.classList.add('correct');
                    explanation.innerHTML = `<span style="color: var(--accent);">‚úó Incorrect.</span> Correct answer: ${q.options[q.correct]}. ${q.explanation}`;
                }
                explanation.style.display = 'block';
            });

            const results = document.getElementById('quizResults');
            const score = document.getElementById('quizScore');
            const feedback = document.getElementById('quizFeedback');

            const percentage = (correct / quizQuestions.length) * 100;

            results.style.display = 'block';
            score.innerHTML = `Score: ${correct} / ${quizQuestions.length} (${percentage.toFixed(1)}%)`;

            if (percentage === 100) {
                feedback.innerHTML = 'üéâ Perfect score! You are an IDS/IPS evasion master!';
                feedback.style.color = 'var(--success)';
                completeSection('quiz', 10);
            } else if (percentage >= 80) {
                feedback.innerHTML = 'üëç Excellent work! You have a strong understanding of IDS/IPS concepts.';
                feedback.style.color = 'var(--success)';
                completeSection('quiz', 10);
            } else if (percentage >= 60) {
                feedback.innerHTML = 'üìö Good effort! Review the explanations and try again for full mastery.';
                feedback.style.color = 'var(--warning)';
            } else {
                feedback.innerHTML = 'üìñ Keep studying! Review the theory section and try again.';
                feedback.style.color = 'var(--accent)';
            }

            // Scroll to results
            results.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        function resetQuiz() {
            initQuiz();
            document.getElementById('quizResults').style.display = 'none';
        }

        // Initialize quiz
        initQuiz();

        // Initialize progress
        updateProgress();

        console.log('%cüîê IDS/IPS Evasion Lab Loaded', 'color: #a855f7; font-size: 16px; font-weight: bold;');
        console.log('%cComplete all sections to earn 75 XP', 'color: #dc2626; font-size: 12px;');
    </script>
<script src="../../components/FluxCapacitor.js"></script>
</body>
</html>